{"version":3,"sources":["ToggleButton.js","AudioDisplay.js","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","Button","color","enabled","disableText","enableText","AudioDisplay","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","ref","onClick","pause","a","console","log","navigator","mediaDevices","getUserMedia","audio","video","stream","detectSilence","audioCtx","sourceAudioNode","onSoundStart","_","onSoundEnd","onDetectionTerminate","silence_delay","min_decibels","analyserNode","AnalyserNode","minDecibels","connect","streamClosed","onended","data","Uint8Array","frequencyBinCount","silence_start","performance","now","triggered","time","requestAnimationFrame","getByteFrequencyData","some","v","Dictaphone","mediaStreamRef","useState","isRecording","setRecordingState","useKeypress","event","altKey","toggleRecording","audioURLs","setAudioURLs","getTracks","forEach","track","stop","releaseMicrophone","getMicrophone","then","streamRef","silenceDetectionPeriodMs","recordingPeriodExtensionMs","chunkSizeMs","numChunksToTrimFromRecordingEnd","AudioContext","sourceNode","createMediaStreamSource","delayNode","DelayNode","delayTime","maxDelayTime","destinationNode","createMediaStreamDestination","recorder","MediaRecorder","chunks","startRec","start","stopRec","ondataavailable","e","push","onstop","length","blob","Blob","slice","newAudioURL","window","URL","createObjectURL","recordAudioClips","setLoop","setAutoplay","Tooltip","title","arrow","TextField","label","placeholder","onChange","target","value","FormGroup","FormControlLabel","control","Checkbox","checked","map","url","App","darkTheme","createTheme","mode","components","MuiButton","defaultProps","variant","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fb126be4.chunk.js","sourcesContent":["import { Button } from '@mui/material';\n\nfunction ToggleButton(props) {\n  return (\n    <Button\n      color={props.enabled ? \"error\" : \"success\"}\n      {...props}\n    >\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\n    </Button>\n  );\n}\n\nexport default ToggleButton;\n","import { useEffect, useRef } from \"react\";\nimport { Box, Button } from '@mui/material';\nimport WaveSurfer from \"wavesurfer.js\";\nimport { useTheme } from '@mui/material/styles';\n\nfunction AudioDisplay(props) {\n  const theme = useTheme()\n\n  const waveSurferDomRef = useRef();\n  const waveSurferRef = useRef();\n\n  useEffect(\n    () => {\n      // WaveSurfer requires the DOM in which it's rendered\n      // to be loaded on the page before calling its create function.\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\n      waveSurferRef.current =\n        WaveSurfer.create(\n          {\n            container: waveSurferDomRef.current,\n            responsive: true,\n          }\n        )\n      \n      // returned function will be called on component unmount\n      return () => {\n        waveSurferRef.current.destroy()\n        waveSurferRef.current = null\n      }\n    },\n    []   // <-- empty dependency array implies 'run once'\n  );\n\n  useEffect(\n    () => {\n      // Setting these values here instead of during WaveSurfer.create()\n      // so component remains fully responsive\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\n    },\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\n  );\n\n  useEffect(\n    () => {\n      if (props.autoplay) {\n        waveSurferRef.current?.on('ready', play);\n      }\n      else {\n        waveSurferRef.current?.un('ready');\n      }\n    },\n    [props.autoplay],\n  )\n\n  useEffect(\n    () => {\n      if (props.audioPath) {\n        waveSurferRef.current?.load(props.audioPath);\n      } else {\n        waveSurferRef.current?.empty()\n      }\n    },\n    [props.audioPath],\n  );\n\n  useEffect(\n    () => {\n      if (props.loop) {\n        waveSurferRef.current?.on('finish', play);\n      }\n      else {\n        waveSurferRef.current?.un('finish');\n      }\n    },\n    [props.loop]\n  );\n\n  function play() {\n    waveSurferRef.current?.play();\n  }\n\n  function pause() {\n    waveSurferRef.current?.pause();\n  }\n\n  return (\n    <Box>\n      <h2>AudioDisplay WIP</h2>\n      <p>Audio Path: {props.audioPath}</p>\n      <div ref={waveSurferDomRef}></div>\n      <Button onClick={play}>Play Audio</Button>\n      <Button onClick={pause}>Pause Audio</Button>\n    </Box>\n  );\n}\n\nexport default AudioDisplay;\n","import { Box, Tooltip, Checkbox, FormGroup, FormControlLabel, TextField } from '@mui/material';\nimport React, {\n  useRef,\n  useState,\n} from \"react\";\nimport ToggleButton from './ToggleButton.js';\nimport AudioDisplay from './AudioDisplay.js';\nimport useKeypress from 'react-use-keypress';\n\n// Bug list:\n// TODO: Need to collect 500ms or so of audio before and after the \n//       We need to be able to trim the MediaRecorder's output on the time (i.e. not chunk) axis\n//       This can be faked by setting the time window really low and trimming on chunks\n//       Won't work for triming the preceding audio if the first chunk contains important metadata\n//       Worth a shot eh\n// TODO: Should trim the \"detected silence\" window from the recording after a silence window\n//       Should NOT trim at all when the user invokes \"Stop Recording\"\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\n\nasync function getMicrophone() {\n  console.log('Open Microphone')\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n    video: false\n  });\n  return stream;\n}\n\nfunction releaseMicrophone(mediaStreamRef) {\n  console.log('Release Microphone', mediaStreamRef)\n  mediaStreamRef.current.getTracks().forEach(track => track.stop());\n  mediaStreamRef.current = null\n}\n\nfunction detectSilence(\n  audioCtx,\n  sourceAudioNode,\n  onSoundStart = _=> {},\n  onSoundEnd = _=> {},\n  onDetectionTerminate = _=> {},\n  silence_delay = 2000,  // in ms\n  min_decibels = -70\n  ) {\n  const analyserNode = new AnalyserNode(audioCtx, {\n    minDecibels: min_decibels,\n  });\n  sourceAudioNode.connect(analyserNode);\n  let streamClosed = false;\n  sourceAudioNode.onended = function () {\n        console.log('Silence Node Closed');\n        streamClosed = true;\n    };\n\n  // FIXME: does this leak memory?\n  const data = new Uint8Array(analyserNode.frequencyBinCount); // will hold our data\n  let silence_start = performance.now();\n  let triggered = false; // trigger only once per silence event\n\n  function loop(time) {\n    if (streamClosed)\n    {\n      console.log(\"yes we have no bananas\")\n      onDetectionTerminate();\n      return;\n    }\n\n    requestAnimationFrame(loop); // we'll loop every 60th of a second to check\n    analyserNode.getByteFrequencyData(data); // get current data\n    if (data.some(v => v)) { // if there is data above the given db limit\n      if(triggered){\n        onSoundStart();\n        triggered = false;\n        console.log(\"Audio Started\")\n        }\n      silence_start = time; // set it to now\n    }\n    if (!triggered && time - silence_start > silence_delay) {\n      onSoundEnd();\n      triggered = true;\n      console.log(\"Audio Stopped\")\n    }\n  }\n  loop();\n}\n\nfunction Dictaphone(props) {\n  // Set/cleared when the user toggles recording\n  const mediaStreamRef = useRef();\n  const [isRecording, setRecordingState] = useState()\n\n  useKeypress('r', (event) => {\n    if (event.altKey) {\n      toggleRecording()\n    }\n  });\n\n  const [audioURLs, setAudioURLs] = useState([])\n\n  function toggleRecording() {\n    if (isRecording)\n    {\n      releaseMicrophone(mediaStreamRef);\n      setRecordingState(false)\n    }\n    else\n    {\n      getMicrophone().then(stream => {\n        mediaStreamRef.current = stream\n        recordAudioClips(mediaStreamRef);\n      });\n      setRecordingState(true)\n    }\n  }\n\n  // Relies on setAudioURLs\n  function recordAudioClips(\n    streamRef,\n    // FIXME: move magic numbers into UI controls\n    silenceDetectionPeriodMs = 2000,\n    recordingPeriodExtensionMs = 250,  // How much audio is retained in each clip before and after silence\n    ) {\n    // Compute remaining time periods\n    const chunkSizeMs = 25;  // pretty arbitrary; tradeoff between precision and performance\n    const numChunksToTrimFromRecordingEnd = (silenceDetectionPeriodMs - 2 * recordingPeriodExtensionMs) / chunkSizeMs;\n\n    // Set up AudioContext\n    const audioCtx = new AudioContext();\n    const sourceNode = audioCtx.createMediaStreamSource(streamRef.current);\n\n    // Record from stream on a delay to allow capturing audio\n    // from before recording is triggered\n    const delayNode = new DelayNode(audioCtx, {\n      delayTime: recordingPeriodExtensionMs / 1000,\n      maxDelayTime: recordingPeriodExtensionMs / 1000,\n    });\n    const destinationNode = audioCtx.createMediaStreamDestination();\n    sourceNode.connect(delayNode).connect(destinationNode);\n    const recorder = new MediaRecorder(destinationNode.stream);\n\n    let chunks = []\n    recorder.ondataavailable =\n      function(e) {\n          chunks.push(e.data);\n      }\n\n    recorder.onstop =\n      function(e) {\n        // FIXME: don't do this - find a way to trim the audio instead\n        // will be required for pre-recording due to the way\n        // audio metadata is embedded in the first chunk\n        // i.e. can't simply drop the first chunk\n        if (chunks.length <= numChunksToTrimFromRecordingEnd) {\n          // Drop this clip as it's too short to be an actual recording\n          console.log(\"Skipping Audio conversion as number of chunks\", chunks.length, \"<\", numChunksToTrimFromRecordingEnd)\n        } else {\n          // Convert recorded audio, trimming off the final silence\n          console.log(\"Converting Audio as number of chunks\", chunks.length, \">\", numChunksToTrimFromRecordingEnd, \"- trimming\", numChunksToTrimFromRecordingEnd)\n          const blob = new Blob(chunks.slice(0, chunks.length - numChunksToTrimFromRecordingEnd), { 'type' : 'audio/ogg; codecs=opus' });\n          const newAudioURL = window.URL.createObjectURL(blob);\n          console.log(\"Generated clip\", newAudioURL);\n          setAudioURLs(audioURLs => [newAudioURL, ...audioURLs])  // Most recent clip first\n        }\n\n        // Reset for next recording\n        chunks = [];\n      }\n\n    // TODO: inline these after debugging\n    function startRec() {\n      console.log('START RECORD')\n      recorder.start(chunkSizeMs)\n    }\n\n    function stopRec() {\n      console.log('STOP RECORD')\n      recorder.stop()\n    }\n\n    // Detect silence on the live audio\n    // FIXME: Why the heck does this work but (..., recorder.start, recorder.stop) doesn't?\n    detectSilence(\n      audioCtx,\n      sourceNode,\n      _ => startRec(),\n      _ => stopRec(),\n      _=> {},  // Do nothing special when the detection routine terminates\n      silenceDetectionPeriodMs,\n      -60  // TODO: remove magic number\n    );\n  }\n\n  // For debugging state transitions on AudioDisplay\n  const [loop, setLoop] = useState(false)  // default to match checkbox\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\n\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\n  // only displays the Tooltip when after the first time the Button is clicked\n  // This is due to the ToggleButton not containing a Ref since it's a function object\n  // Need to either make it a class or find another way around\n  return (\n    <Box>\n      <h2>Dictaphone WIP \"Effervescence\"</h2>\n      <Tooltip title=\"Toggle with Alt-R\" arrow>\n        <ToggleButton\n          enabled={isRecording}\n          enableText=\"Start Recording\"\n          disableText=\"Stop Recording\"\n          onClick={toggleRecording}\n        />\n      </Tooltip>\n      <TextField\n        label=\"Custom Audio File Path\"\n        placeholder=\"Hello hello\"\n        onChange={(e) => setAudioURLs([e.target.value])}\n      />\n      <FormGroup>\n        <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\n        <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\n      </FormGroup>\n      {/* FIXME: update key with some sort of name? */}\n      {audioURLs.map(url => <AudioDisplay key={url} audioPath={url} autoplay={autoplay} loop={loop}/>)}\n    </Box>\n  );\n}\n\nexport default Dictaphone;\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\nimport { CssBaseline } from '@mui/material';\nimport './App.css';\n\n// import LandingPage from './LandingPage.js';\nimport Dictaphone from './Dictaphone.js';\n\nfunction App() {\n  const darkTheme = createTheme({\n    palette: {\n      mode: 'dark',\n    },\n    components: {\n      MuiButton: {\n        defaultProps: {\n          variant: 'outlined',\n        },\n      },\n    },\n  });\n\n  return (\n    <ThemeProvider theme={darkTheme}>\n      <CssBaseline />\n      {/* <LandingPage /> */}\n      <Dictaphone />\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}