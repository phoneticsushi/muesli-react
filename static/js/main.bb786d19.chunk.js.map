{"version":3,"sources":["ToggleButton.js","AudioDisplay.js","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","Button","color","enabled","disableText","enableText","AudioDisplay","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","ref","onClick","pause","a","console","log","navigator","mediaDevices","getUserMedia","audio","video","stream","detectSilence","streamRef","onSoundStart","_","onSoundEnd","onDetectionTerminate","silence_delay","min_decibels","ctx","AudioContext","analyser","createAnalyser","streamNode","createMediaStreamSource","connect","minDecibels","data","Uint8Array","frequencyBinCount","silence_start","performance","now","triggered","time","requestAnimationFrame","getByteFrequencyData","some","v","Dictaphone","mediaStreamRef","useState","isRecording","setRecordingState","useKeypress","event","altKey","toggleRecording","audioURLs","setAudioURLs","getTracks","forEach","track","stop","releaseMicrophone","getMicrophone","then","silenceLengthMs","recorder","MediaRecorder","chunks","chunkSizeMs","numSilenceChunks","ondataavailable","e","push","onstop","length","blob","Blob","slice","newAudioURL","window","URL","createObjectURL","start","recordAudioClips","setLoop","setAutoplay","Tooltip","title","arrow","TextField","label","placeholder","onChange","target","value","FormGroup","FormControlLabel","control","Checkbox","checked","map","url","App","darkTheme","createTheme","mode","components","MuiButton","defaultProps","variant","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bb786d19.chunk.js","sourcesContent":["import { Button } from '@mui/material';\n\nfunction ToggleButton(props) {\n  return (\n    <Button\n      color={props.enabled ? \"error\" : \"success\"}\n      {...props}\n    >\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\n    </Button>\n  );\n}\n\nexport default ToggleButton;\n","import { useEffect, useRef } from \"react\";\nimport { Box, Button } from '@mui/material';\nimport WaveSurfer from \"wavesurfer.js\";\nimport { useTheme } from '@mui/material/styles';\n\nfunction AudioDisplay(props) {\n  const theme = useTheme()\n\n  const waveSurferDomRef = useRef();\n  const waveSurferRef = useRef();\n\n  useEffect(\n    () => {\n      // WaveSurfer requires the DOM in which it's rendered\n      // to be loaded on the page before calling its create function.\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\n      waveSurferRef.current =\n        WaveSurfer.create(\n          {\n            container: waveSurferDomRef.current,\n            responsive: true,\n          }\n        )\n      \n      // returned function will be called on component unmount\n      return () => {\n        waveSurferRef.current.destroy()\n        waveSurferRef.current = null\n      }\n    },\n    []   // <-- empty dependency array implies 'run once'\n  );\n\n  useEffect(\n    () => {\n      // Setting these values here instead of during WaveSurfer.create()\n      // so component remains fully responsive\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\n    },\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\n  );\n\n  useEffect(\n    () => {\n      if (props.autoplay) {\n        waveSurferRef.current?.on('ready', play);\n      }\n      else {\n        waveSurferRef.current?.un('ready');\n      }\n    },\n    [props.autoplay],\n  )\n\n  useEffect(\n    () => {\n      if (props.audioPath) {\n        waveSurferRef.current?.load(props.audioPath);\n      } else {\n        waveSurferRef.current?.empty()\n      }\n    },\n    [props.audioPath],\n  );\n\n  useEffect(\n    () => {\n      if (props.loop) {\n        waveSurferRef.current?.on('finish', play);\n      }\n      else {\n        waveSurferRef.current?.un('finish');\n      }\n    },\n    [props.loop]\n  );\n\n  function play() {\n    waveSurferRef.current?.play();\n  }\n\n  function pause() {\n    waveSurferRef.current?.pause();\n  }\n\n  return (\n    <Box>\n      <h2>AudioDisplay WIP</h2>\n      <p>Audio Path: {props.audioPath}</p>\n      <div ref={waveSurferDomRef}></div>\n      <Button onClick={play}>Play Audio</Button>\n      <Button onClick={pause}>Pause Audio</Button>\n    </Box>\n  );\n}\n\nexport default AudioDisplay;\n","import { Box, Tooltip, Checkbox, FormGroup, FormControlLabel, TextField } from '@mui/material';\nimport React, {\n  useRef,\n  useState,\n} from \"react\";\nimport ToggleButton from './ToggleButton.js';\nimport AudioDisplay from './AudioDisplay.js';\nimport useKeypress from 'react-use-keypress';\n\n// Bug list:\n// TODO: Need to collect 500ms or so of audio before and after the \n//       We need to be able to trim the MediaRecorder's output on the time (i.e. not chunk) axis\n//       This can be faked by setting the time window really low and trimming on chunks\n//       Won't work for triming the preceding audio if the first chunk contains important metadata\n//       Worth a shot eh\n// TODO: Should trim the \"detected silence\" window from the recording after a silence window\n//       Should NOT trim at all when the user invokes \"Stop Recording\"\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\n\nasync function getMicrophone() {\n  console.log('Open Microphone')\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n    video: false\n  });\n  return stream;\n}\n\nfunction releaseMicrophone(mediaStreamRef) {\n  console.log('Release Microphone', mediaStreamRef)\n  mediaStreamRef.current.getTracks().forEach(track => track.stop());\n  mediaStreamRef.current = null\n}\n\nfunction detectSilence(\n  streamRef,\n  onSoundStart = _=> {},\n  onSoundEnd = _=> {},\n  onDetectionTerminate = _=> {},\n  silence_delay = 2000,  // in ms\n  min_decibels = -70\n  ) {\n  const ctx = new AudioContext();\n  const analyser = ctx.createAnalyser();\n  const streamNode = ctx.createMediaStreamSource(streamRef.current);\n  streamNode.connect(analyser);\n  analyser.minDecibels = min_decibels;\n\n  // FIXME: does this leak memory?\n  const data = new Uint8Array(analyser.frequencyBinCount); // will hold our data\n  let silence_start = performance.now();\n  let triggered = false; // trigger only once per silence event\n\n  function loop(time) {\n    if (streamRef.current == null)\n    {\n      onDetectionTerminate();\n      return;\n    }\n\n    requestAnimationFrame(loop); // we'll loop every 60th of a second to check\n    analyser.getByteFrequencyData(data); // get current data\n    if (data.some(v => v)) { // if there is data above the given db limit\n      if(triggered){\n        onSoundStart();\n        triggered = false;\n        console.log(\"Audio Started\")\n        }\n      silence_start = time; // set it to now\n    }\n    if (!triggered && time - silence_start > silence_delay) {\n      onSoundEnd();\n      triggered = true;\n      console.log(\"Audio Stopped\")\n    }\n  }\n  loop();\n}\n\nfunction Dictaphone(props) {\n  // Set/cleared when the user toggles recording\n  const mediaStreamRef = useRef();\n  const [isRecording, setRecordingState] = useState()\n\n  useKeypress('r', (event) => {\n    if (event.altKey) {\n      toggleRecording()\n    }\n  });\n\n  const [audioURLs, setAudioURLs] = useState([])\n\n  function toggleRecording() {\n    if (isRecording)\n    {\n      releaseMicrophone(mediaStreamRef);\n      setRecordingState(false)\n    }\n    else\n    {\n      getMicrophone().then(stream => {\n        mediaStreamRef.current = stream\n        recordAudioClips(mediaStreamRef);\n      });\n      setRecordingState(true)\n    }\n  }\n\n  // Relies on setAudioURLs\n  function recordAudioClips(streamRef, silenceLengthMs = 2000) {\n    const recorder = new MediaRecorder(streamRef.current);\n    let chunks = []\n    // FIXME: move magic numbers into UI controls\n    const chunkSizeMs = 50\n    const numSilenceChunks = silenceLengthMs / chunkSizeMs\n\n    recorder.ondataavailable =\n      function(e) {\n          chunks.push(e.data);\n      }\n\n    recorder.onstop =\n      function(e) {\n        // FIXME: don't do this - find a way to trim the audio instead\n        // will be required for pre-recording due to the way\n        // audio metadata is embedded in the first chunk\n        // i.e. can't simply drop the first chunk\n        if (chunks.length <= numSilenceChunks) {\n          // Drop this clip as it's too short to be an actual recording\n          console.log(\"Skipping Audio conversion as number of chunks\", chunks.length, \"<\", numSilenceChunks)\n        } else {\n          // Convert recorded audio, trimming off the final silence\n          console.log(\"Converting Audio as number of chunks\", chunks.length, \">\", numSilenceChunks)\n          const blob = new Blob(chunks.slice(0, chunks.length - numSilenceChunks), { 'type' : 'audio/ogg; codecs=opus' });\n          const newAudioURL = window.URL.createObjectURL(blob);\n          console.log(\"Generated clip\", newAudioURL);\n          setAudioURLs(audioURLs => [newAudioURL, ...audioURLs])  // Most recent clip first\n        }\n\n        // Reset for next recording\n        chunks = [];\n      }\n\n    // FIXME: Why the heck does this work but (streamRef, recorder.start, recorder.stop) doesn't?\n    detectSilence(\n      streamRef,\n      _ => recorder.start(chunkSizeMs),\n      _ => recorder.stop(),\n      _=> {},  // Do nothing special when the detection routine terminates\n      silenceLengthMs,\n      -70  // TODO: remove magic number\n    );\n  }\n\n  // For debugging state transitions on AudioDisplay\n  const [loop, setLoop] = useState(false)  // default to match checkbox\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\n\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\n  // only displays the Tooltip when after the first time the Button is clicked\n  // This is due to the ToggleButton not containing a Ref since it's a function object\n  // Need to either make it a class or find another way around\n  return (\n    <Box>\n      <h2>Dictaphone WIP</h2>\n      <Tooltip title=\"Toggle with Alt-R\" arrow>\n        <ToggleButton\n          enabled={isRecording}\n          enableText=\"Start Recording\"\n          disableText=\"Stop Recording\"\n          onClick={toggleRecording}\n        />\n      </Tooltip>\n      <TextField\n        label=\"Custom Audio File Path\"\n        placeholder=\"Hello hello\"\n        onChange={(e) => setAudioURLs([e.target.value])}\n      />\n      <FormGroup>\n        <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\n        <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\n      </FormGroup>\n      {/* FIXME: update key with some sort of name? */}\n      {audioURLs.map(url => <AudioDisplay key={url} audioPath={url} autoplay={autoplay} loop={loop}/>)}\n    </Box>\n  );\n}\n\nexport default Dictaphone;\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\nimport { CssBaseline } from '@mui/material';\nimport './App.css';\n\n// import LandingPage from './LandingPage.js';\nimport Dictaphone from './Dictaphone.js';\n\nfunction App() {\n  const darkTheme = createTheme({\n    palette: {\n      mode: 'dark',\n    },\n    components: {\n      MuiButton: {\n        defaultProps: {\n          variant: 'outlined',\n        },\n      },\n    },\n  });\n\n  return (\n    <ThemeProvider theme={darkTheme}>\n      <CssBaseline />\n      {/* <LandingPage /> */}\n      <Dictaphone />\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}