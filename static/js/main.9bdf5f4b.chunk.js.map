{"version":3,"sources":["ToggleButton.js","AudioDisplay.js","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","Button","color","enabled","disableText","enableText","AudioDisplay","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","name","getDuration","ref","onClick","pause","a","console","log","navigator","mediaDevices","getUserMedia","audio","video","stream","detectSilence","audioCtx","sourceAudioNode","silence_delay_ms","min_decibels","onSoundStart","_","onSoundEnd","onDetectionTerminate","analyserNode","AnalyserNode","minDecibels","connect","streamClosed","onended","data","Uint8Array","frequencyBinCount","silence_start","performance","now","activelyRecording","time","requestAnimationFrame","getByteFrequencyData","some","v","Dictaphone","mediaStreamRef","useState","isRecording","setRecordingState","recordingText","setRecordingText","useKeypress","event","altKey","toggleRecording","audioClips","setAudioClips","getTracks","forEach","track","stop","releaseMicrophone","getMicrophone","then","streamRef","silenceDetectionPeriodMs","recordingPeriodExtensionMs","insignificantClipDurationMs","chunkSizeMs","numChunksToTrimFromRecordingEnd","numChunksForInsignificantClip","AudioContext","sourceNode","createMediaStreamSource","delayNode","DelayNode","delayTime","maxDelayTime","destinationNode","createMediaStreamDestination","recorder","MediaRecorder","chunks","startRec","start","stopRec","ondataavailable","e","push","onstop","length","blob","Blob","slice","newClip","randomWords","exactly","wordsPerString","separator","url","window","URL","createObjectURL","clips","recordAudioClips","setLoop","setAutoplay","Tooltip","title","arrow","TextField","label","placeholder","onChange","target","value","FormGroup","FormControlLabel","control","Checkbox","checked","map","clip","App","darkTheme","createTheme","mode","components","MuiButton","defaultProps","variant","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9bdf5f4b.chunk.js","sourcesContent":["import { Button } from '@mui/material';\n\nfunction ToggleButton(props) {\n  return (\n    <Button\n      color={props.enabled ? \"error\" : \"success\"}\n      {...props}\n    >\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\n    </Button>\n  );\n}\n\nexport default ToggleButton;\n","import { useEffect, useRef } from \"react\";\nimport { Box, Button } from '@mui/material';\nimport WaveSurfer from \"wavesurfer.js\";\nimport { useTheme } from '@mui/material/styles';\n\nfunction AudioDisplay(props) {\n  const theme = useTheme()\n\n  const waveSurferDomRef = useRef();\n  const waveSurferRef = useRef();\n\n  useEffect(\n    () => {\n      // WaveSurfer requires the DOM in which it's rendered\n      // to be loaded on the page before calling its create function.\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\n      waveSurferRef.current =\n        WaveSurfer.create(\n          {\n            container: waveSurferDomRef.current,\n            responsive: true,\n          }\n        )\n      \n      // returned function will be called on component unmount\n      return () => {\n        waveSurferRef.current.destroy()\n        waveSurferRef.current = null\n      }\n    },\n    []   // <-- empty dependency array implies 'run once'\n  );\n\n  useEffect(\n    () => {\n      // Setting these values here instead of during WaveSurfer.create()\n      // so component remains fully responsive\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\n    },\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\n  );\n\n  useEffect(\n    () => {\n      if (props.autoplay) {\n        waveSurferRef.current?.on('ready', play);\n      }\n      else {\n        waveSurferRef.current?.un('ready');\n      }\n    },\n    [props.autoplay],\n  )\n\n  useEffect(\n    () => {\n      if (props.audioPath) {\n        waveSurferRef.current?.load(props.audioPath);\n      } else {\n        waveSurferRef.current?.empty()\n      }\n    },\n    [props.audioPath],\n  );\n\n  useEffect(\n    () => {\n      if (props.loop) {\n        waveSurferRef.current?.on('finish', play);\n      }\n      else {\n        waveSurferRef.current?.un('finish');\n      }\n    },\n    [props.loop]\n  );\n\n  function play() {\n    waveSurferRef.current?.play();\n  }\n\n  function pause() {\n    waveSurferRef.current?.pause();\n  }\n\n  return (\n    <Box>\n      <h2>AudioDisplay WIP: {props.name || \"No Name\"}</h2>\n      <p>Audio Path: {props.audioPath}</p>\n      <p>Audio Duration: {waveSurferRef.current?.getDuration() * 1000}ms</p>{/* FIXME: duration not available until later; use state */}\n      <div ref={waveSurferDomRef}></div>\n      <Button onClick={play}>Play Audio</Button>\n      <Button onClick={pause}>Pause Audio</Button>\n    </Box>\n  );\n}\n\nexport default AudioDisplay;\n","import { Box, Tooltip, Checkbox, FormGroup, FormControlLabel, TextField } from '@mui/material';\nimport React, {\n  useRef,\n  useState,\n} from \"react\";\nimport ToggleButton from './ToggleButton.js';\nimport AudioDisplay from './AudioDisplay.js';\nimport useKeypress from 'react-use-keypress';\nimport randomWords from 'random-words';\n\n// Bug list:\n// TODO: Need to collect 500ms or so of audio before and after the \n//       We need to be able to trim the MediaRecorder's output on the time (i.e. not chunk) axis\n//       This can be faked by setting the time window really low and trimming on chunks\n//       Won't work for triming the preceding audio if the first chunk contains important metadata\n//       Worth a shot eh\n// TODO: Should trim the \"detected silence\" window from the recording after a silence window\n//       Should NOT trim at all when the user invokes \"Stop Recording\"\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\n\nasync function getMicrophone() {\n  console.log('Open Microphone')\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true,\n    video: false\n  });\n  return stream;\n}\n\nfunction releaseMicrophone(mediaStreamRef) {\n  console.log('Release Microphone', mediaStreamRef)\n  mediaStreamRef.current.getTracks().forEach(track => track.stop());\n  mediaStreamRef.current = null\n}\n\nfunction detectSilence(\n  audioCtx,\n  sourceAudioNode,\n  silence_delay_ms,\n  min_decibels,\n  onSoundStart = _=> {},\n  onSoundEnd = _=> {},\n  onDetectionTerminate = _=> {},\n  ) {\n  const analyserNode = new AnalyserNode(audioCtx, {\n    minDecibels: min_decibels,\n  });\n  sourceAudioNode.connect(analyserNode);\n  let streamClosed = false;\n  sourceAudioNode.onended = function () {\n        console.log('Silence Node Closed');\n        streamClosed = true;\n    };\n\n  // FIXME: does this leak memory?\n  const data = new Uint8Array(analyserNode.frequencyBinCount); // will hold our data\n  let silence_start = performance.now();\n  let activelyRecording = false; // trigger only once per silence event\n\n  function loop(time) {\n    if (streamClosed)\n    {\n      console.log(\"yes we have no bananas\")\n      onDetectionTerminate();\n      return;\n    }\n\n    requestAnimationFrame(loop); // we'll loop every 60th of a second to check\n    analyserNode.getByteFrequencyData(data); // get current data\n    if (data.some(v => v)) { // if there is data above the given db limit\n      if(!activelyRecording){\n        onSoundStart();\n        activelyRecording = true;\n        console.log(\"Audio Started\")\n        }\n      silence_start = time; // set it to now\n    }\n    if (activelyRecording && time - silence_start > silence_delay_ms) {\n      onSoundEnd();\n      activelyRecording = false;\n      console.log(\"Audio Stopped\")\n    }\n  }\n  loop();\n}\n\nfunction Dictaphone(props) {\n  // Set/cleared when the user toggles recording\n  const mediaStreamRef = useRef();\n  //TODO: disambiguate between mic open and actually recording\n  const [isRecording, setRecordingState] = useState()\n  const [recordingText, setRecordingText] = useState('First Load')\n\n  useKeypress('r', (event) => {\n    if (event.altKey) {\n      toggleRecording()\n    }\n  });\n\n  const [audioClips, setAudioClips] = useState([])\n\n  function toggleRecording() {\n    if (isRecording)\n    {\n      releaseMicrophone(mediaStreamRef);\n      setRecordingState(false)\n      setRecordingText('Recording is Off')\n    }\n    else\n    {\n      getMicrophone().then(stream => {\n        mediaStreamRef.current = stream\n        recordAudioClips(mediaStreamRef);\n      });\n      setRecordingState(true)\n    }\n  }\n\n  // Relies on setAudioClips\n  function recordAudioClips(\n    streamRef,\n    // FIXME: move magic numbers into UI controls\n    silenceDetectionPeriodMs = 2000,\n    recordingPeriodExtensionMs = 500,  // How much audio is retained in each clip before and after silence\n    insignificantClipDurationMs = 1000,  // Clips shorter than this won't be saved\n    ) {\n    // Compute remaining time periods\n    // NOTE: there appears to be an undocumented minimum chunk size value o ~60ms (on Firefox at least).\n    // Below 60ms, this implementation breaks since it relies on the chunk size being valid to trim the audio correctly.\n    // FIXME: split audio based on samples/timestamps rather than relying on the recorder to work properly\n    const chunkSizeMs = 100;  // pretty arbitrary; tradeoff between precision and performance\n    const numChunksToTrimFromRecordingEnd = (silenceDetectionPeriodMs - 2 * recordingPeriodExtensionMs) / chunkSizeMs;\n    const numChunksForInsignificantClip = insignificantClipDurationMs / chunkSizeMs;\n\n    // Set up AudioContext\n    const audioCtx = new AudioContext();\n    const sourceNode = audioCtx.createMediaStreamSource(streamRef.current);\n\n    // Record from stream on a delay to allow capturing audio\n    // from before recording is triggered\n    const delayNode = new DelayNode(audioCtx, {\n      delayTime: recordingPeriodExtensionMs / 1000,\n      maxDelayTime: recordingPeriodExtensionMs / 1000,\n    });\n    const destinationNode = audioCtx.createMediaStreamDestination();\n    sourceNode.connect(delayNode).connect(destinationNode);\n    const recorder = new MediaRecorder(destinationNode.stream);\n\n    let chunks = []\n    recorder.ondataavailable =\n      function(e) {\n          chunks.push(e.data);\n      }\n\n    recorder.onstop =\n      function(e) {\n        if (chunks.length <= numChunksForInsignificantClip) {\n          // Drop this clip as it's too short to be an actual recording\n          console.log(\"Skipping Audio conversion as number of chunks\", chunks.length, \"<=\", numChunksForInsignificantClip)\n        } else {\n          // Convert recorded audio, trimming off the final silence\n          console.log(\"Converting Audio as number of chunks\", chunks.length, \">\", numChunksForInsignificantClip, \"- trimming\", numChunksToTrimFromRecordingEnd)\n          const blob = new Blob(chunks.slice(0, chunks.length - numChunksToTrimFromRecordingEnd), { 'type' : 'audio/ogg; codecs=opus' });\n          const newClip = {\n            name: randomWords({exactly: 1, wordsPerString: 2, separator: '-'})[0],  // Returns array for some reason\n            url: window.URL.createObjectURL(blob)\n          }\n          console.log(\"Generated clip\", newClip);\n          setAudioClips(clips => [newClip, ...clips])  // Most recent clip first\n        }\n\n        // Reset for next recording\n        chunks = [];\n      }\n\n    // TODO: inline these after debugging\n    function startRec() {\n      setRecordingText(`RECORDING with chunk size ${chunkSizeMs}`)\n      recorder.start(chunkSizeMs)\n    }\n\n    function stopRec() {\n      setRecordingText('Waiting for audio...')\n      recorder.stop()\n    }\n\n    // Detect silence on the live audio\n    // FIXME: Why the heck does this work but (..., recorder.start, recorder.stop) doesn't?\n    detectSilence(\n      audioCtx,\n      sourceNode,\n      silenceDetectionPeriodMs,\n      -60,  // TODO: remove magic number\n      _ => startRec(),\n      _ => stopRec(),\n      _=> {},  // Do nothing special when the detection routine terminates\n    );\n  }\n\n  // For debugging state transitions on AudioDisplay\n  const [loop, setLoop] = useState(false)  // default to match checkbox\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\n\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\n  // only displays the Tooltip when after the first time the Button is clicked\n  // This is due to the ToggleButton not containing a Ref since it's a function object\n  // Need to either make it a class or find another way around\n  return (\n    <Box>\n      <h2>Dictaphone WIP \"Effervescence\"</h2>\n      <Tooltip title=\"Toggle with Alt-R\" arrow>\n        <ToggleButton\n          enabled={isRecording}\n          enableText=\"Start Recording\"\n          disableText=\"Stop Recording\"\n          onClick={toggleRecording}\n        />\n      </Tooltip>\n      <TextField\n        label=\"Custom Audio File Path\"\n        placeholder=\"Hello hello\"\n        onChange={(e) => setAudioClips([{url: e.target.value}])}\n      />\n      {recordingText}\n      <FormGroup>\n        <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\n        <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\n      </FormGroup>\n      {/* FIXME: Update key with some server-sidable ID instead of the URL?*/}\n      {audioClips.map(clip => <AudioDisplay key={clip.url} name={clip.name} audioPath={clip.url} autoplay={autoplay} loop={loop}/>)}\n    </Box>\n  );\n}\n\nexport default Dictaphone;\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\nimport { CssBaseline } from '@mui/material';\nimport './App.css';\n\n// import LandingPage from './LandingPage.js';\nimport Dictaphone from './Dictaphone.js';\n\nfunction App() {\n  const darkTheme = createTheme({\n    palette: {\n      mode: 'dark',\n    },\n    components: {\n      MuiButton: {\n        defaultProps: {\n          variant: 'outlined',\n        },\n      },\n    },\n  });\n\n  return (\n    <ThemeProvider theme={darkTheme}>\n      <CssBaseline />\n      {/* <LandingPage /> */}\n      <Dictaphone />\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}