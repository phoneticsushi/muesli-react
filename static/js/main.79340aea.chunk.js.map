{"version":3,"sources":["ToggleButton.tsx","AudioDisplay.js","Recorder.ts","NumberTextField.tsx","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","enabled","enableText","disableText","passthroughProps","Button","color","AudioDisplay","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","name","getDuration","ref","onClick","pause","detectSilence","audioCtx","sourceAudioNode","silence_delay_ms","min_decibels","onSoundStart","onSilenceDurationMs","silenceDuration","onSoundEnd","analyserNode","AnalyserNode","minDecibels","connect","data","Uint8Array","frequencyBinCount","silence_start","performance","now","activelyRecording","getByteFrequencyData","some","v","console","log","silenceDurationMs","analysisInterval","setInterval","clearInterval","recordAudioClips","mediaStream","onTimeUntilClipEndsMs","onNewClip","silenceDetectionPeriodMs","insignificantClipDurationMs","silenceThresholdDbfs","recordingPeriodExtensionMs","chunkSizeMs","timeToTrimFromRecordingEndMs","numChunksToTrimFromRecordingEnd","numChunksForInsignificantClip","AudioContext","sourceNode","createMediaStreamSource","delayNode","DelayNode","delayTime","maxDelayTime","destinationNode","createMediaStreamDestination","recorder","MediaRecorder","stream","chunks","ondataavailable","e","push","onstop","length","blob","Blob","slice","newClip","randomWords","exactly","wordsPerString","separator","url","window","URL","createObjectURL","stopSilenceDetection","start","Math","max","stop","state","close","getTracks","forEach","track","NumberTextField","useState","inputHasError","setInputHasError","minValue","maxValue","onChange","TextField","error","text","inputValue","Number","target","value","trim","isNaN","ingestInput","helperText","Dictaphone","recordingCleanupFunction","isMicrophoneOpen","setMicrophoneOpen","timeUntilClipEndsMs","setTimeUntilClipEndsMs","setInsignificantClipDurationMs","setSilenceDetectionPeriodMs","useKeypress","event","altKey","toggleMicrophoneOpen","audioClips","setAudioClips","navigator","mediaDevices","getUserMedia","audio","video","then","addAudioClip","clips","setLoop","setAutoplay","className","Grid","spacing","item","id","xs","sm","md","lg","Stack","Tooltip","title","arrow","String","floor","LinearProgress","variant","label","placeholder","disabled","InputProps","endAdornment","InputAdornment","position","defaultValue","FormGroup","FormControlLabel","control","Checkbox","checked","map","clip","App","darkTheme","createTheme","mode","background","default","components","MuiButton","defaultProps","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.79340aea.chunk.js","sourcesContent":["import { Button } from '@mui/material';\r\n\r\ntype ToggleButtonProps = {\r\n  enabled?: boolean,\r\n  enableText?: string,\r\n  disableText?: string\r\n}\r\n\r\nfunction ToggleButton(props: ToggleButtonProps) {\r\n  const {enabled, enableText, disableText, ...passthroughProps} = props\r\n\r\n  return (\r\n    <Button\r\n      color={props.enabled ? \"error\" : \"success\"}\r\n      {...passthroughProps}\r\n    >\r\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\r\n    </Button>\r\n  );\r\n}\r\n\r\nexport default ToggleButton;\r\n","import { useEffect, useRef } from \"react\";\r\nimport { Box, Button } from '@mui/material';\r\nimport WaveSurfer from \"wavesurfer.js\";\r\nimport { useTheme } from '@mui/material/styles';\r\n\r\nfunction AudioDisplay(props) {\r\n  const theme = useTheme()\r\n\r\n  const waveSurferDomRef = useRef();\r\n  const waveSurferRef = useRef();\r\n\r\n  useEffect(\r\n    () => {\r\n      // WaveSurfer requires the DOM in which it's rendered\r\n      // to be loaded on the page before calling its create function.\r\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\r\n      waveSurferRef.current =\r\n        WaveSurfer.create(\r\n          {\r\n            container: waveSurferDomRef.current,\r\n            responsive: true,\r\n          }\r\n        )\r\n      \r\n      // returned function will be called on component unmount\r\n      return () => {\r\n        waveSurferRef.current.destroy()\r\n        waveSurferRef.current = null\r\n      }\r\n    },\r\n    []   // <-- empty dependency array implies 'run once'\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      // Setting these values here instead of during WaveSurfer.create()\r\n      // so component remains fully responsive\r\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\r\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\r\n    },\r\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.autoplay) {\r\n        waveSurferRef.current?.on('ready', play);\r\n      }\r\n      else {\r\n        waveSurferRef.current?.un('ready');\r\n      }\r\n    },\r\n    [props.autoplay],\r\n  )\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.audioPath) {\r\n        waveSurferRef.current?.load(props.audioPath);\r\n      } else {\r\n        waveSurferRef.current?.empty()\r\n      }\r\n    },\r\n    [props.audioPath],\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.loop) {\r\n        waveSurferRef.current?.on('finish', play);\r\n      }\r\n      else {\r\n        waveSurferRef.current?.un('finish');\r\n      }\r\n    },\r\n    [props.loop]\r\n  );\r\n\r\n  function play() {\r\n    waveSurferRef.current?.play();\r\n  }\r\n\r\n  function pause() {\r\n    waveSurferRef.current?.pause();\r\n  }\r\n\r\n  return (\r\n    <Box>\r\n      <h2>AudioDisplay WIP: {props.name || \"No Name\"}</h2>\r\n      <p>Audio Path: {props.audioPath}</p>\r\n      <p>Audio Duration: {waveSurferRef.current?.getDuration() * 1000}ms</p>{/* FIXME: duration not available until later; use state */}\r\n      <div ref={waveSurferDomRef}></div>\r\n      <Button onClick={play}>Play Audio</Button>\r\n      <Button onClick={pause}>Pause Audio</Button>\r\n    </Box>\r\n  );\r\n}\r\n\r\nexport default AudioDisplay;\r\n","import randomWords from 'random-words';\r\nimport { MuesliAudioClip } from './Types';\r\n\r\nfunction detectSilence(\r\n  audioCtx: AudioContext,\r\n  sourceAudioNode: AudioNode,\r\n  silence_delay_ms: number,\r\n  min_decibels: number,\r\n  onSoundStart = () => {},\r\n  onSilenceDurationMs = (silenceDuration: number) => {},\r\n  onSoundEnd = () => {},\r\n  ): () => void {\r\n  const analyserNode = new AnalyserNode(audioCtx, {\r\n    minDecibels: min_decibels,\r\n  });\r\n  sourceAudioNode.connect(analyserNode);\r\n\r\n  // FIXME: does this leak memory?\r\n  const data = new Uint8Array(analyserNode.frequencyBinCount); // will hold our data\r\n  let silence_start = performance.now();\r\n  let activelyRecording = false; // trigger only once per silence event\r\n\r\n  function loop() {\r\n    const now: DOMHighResTimeStamp = performance.now()\r\n    analyserNode.getByteFrequencyData(data); // get current data\r\n    if (data.some(v => v)) { // if there is data above the given db limit\r\n      if(!activelyRecording){\r\n        onSoundStart();\r\n        activelyRecording = true;\r\n        console.log(\"Detected Audio\")\r\n        }\r\n      silence_start = now; // set it to now\r\n    }\r\n    const silenceDurationMs = now - silence_start\r\n    onSilenceDurationMs(silenceDurationMs)\r\n    if (activelyRecording && silenceDurationMs > silence_delay_ms) {\r\n      onSoundEnd();\r\n      activelyRecording = false;\r\n      console.log(\"Detected Silence\")\r\n    }\r\n  }\r\n\r\n  const analysisInterval = setInterval(loop, 100);  // Arbitrary delay\r\n  // Cleanup Function\r\n  return () => {\r\n    clearInterval(analysisInterval)\r\n    console.log('Ran cleanup function for silence detection')\r\n  }\r\n}\r\n\r\nfunction recordAudioClips(\r\n  mediaStream: MediaStream,\r\n  onTimeUntilClipEndsMs: (timeUntilClipEndsMs: number) => void,\r\n  onNewClip: (clip: MuesliAudioClip) => void,\r\n  silenceDetectionPeriodMs: number,\r\n  insignificantClipDurationMs: number,  // Clips shorter than this won't be saved\r\n  // FIXME: move magic numbers into UI controls\r\n  silenceThresholdDbfs = -60,\r\n  recordingPeriodExtensionMs = 500,  // How much audio is retained in each clip before and after silence\r\n  ): () => void {\r\n  // Compute remaining time periods\r\n  // NOTE: there appears to be an undocumented minimum chunk size value o ~60ms (on Firefox at least).\r\n  // Below 60ms, this implementation breaks since it relies on the chunk size being valid to trim the audio correctly.\r\n  // FIXME: split audio based on samples/timestamps rather than relying on the recorder to work properly\r\n  const chunkSizeMs = 100;  // pretty arbitrary; tradeoff between precision and performance\r\n  const timeToTrimFromRecordingEndMs = silenceDetectionPeriodMs - 2 * recordingPeriodExtensionMs\r\n  const numChunksToTrimFromRecordingEnd = timeToTrimFromRecordingEndMs / chunkSizeMs;\r\n  const numChunksForInsignificantClip = insignificantClipDurationMs / chunkSizeMs;\r\n\r\n  // Set up AudioContext\r\n  const audioCtx = new AudioContext();\r\n  const sourceNode = audioCtx.createMediaStreamSource(mediaStream);\r\n\r\n  // Record from stream on a delay to allow capturing audio\r\n  // from before recording is triggered\r\n  const delayNode = new DelayNode(audioCtx, {\r\n    delayTime: recordingPeriodExtensionMs / 1000,\r\n    maxDelayTime: recordingPeriodExtensionMs / 1000,\r\n  });\r\n  const destinationNode = audioCtx.createMediaStreamDestination();\r\n  sourceNode.connect(delayNode).connect(destinationNode);\r\n  const recorder = new MediaRecorder(destinationNode.stream);\r\n\r\n  let chunks: Blob[] = []\r\n  recorder.ondataavailable =\r\n    function(e) {\r\n        chunks.push(e.data);\r\n    }\r\n\r\n  recorder.onstop =\r\n    function(e) {\r\n      if (chunks.length <= numChunksForInsignificantClip) {\r\n        // Drop this clip as it's too short to be an actual recording\r\n        console.log(\"Skipping Audio conversion as number of chunks\", chunks.length, \"<=\", numChunksForInsignificantClip)\r\n      } else {\r\n        // Convert recorded audio, trimming off the final silence\r\n        console.log(\"Converting Audio as number of chunks\", chunks.length, \">\", numChunksForInsignificantClip, \"- trimming\", numChunksToTrimFromRecordingEnd)\r\n        const blob = new Blob(chunks.slice(0, chunks.length - numChunksToTrimFromRecordingEnd), { 'type' : 'audio/ogg; codecs=opus' });\r\n        const newClip = {\r\n          name: randomWords({exactly: 1, wordsPerString: 2, separator: '-'})[0],  // Returns array for some reason\r\n          url: window.URL.createObjectURL(blob)\r\n        }\r\n        console.log(\"Generated clip\", newClip);\r\n        onNewClip(newClip)\r\n      }\r\n\r\n      // Reset for next recording\r\n      chunks = [];\r\n    }\r\n\r\n  // Detect silence on the live audio\r\n  const stopSilenceDetection = detectSilence(\r\n    audioCtx,\r\n    sourceNode,\r\n    silenceDetectionPeriodMs,\r\n    silenceThresholdDbfs,\r\n    () => recorder.start(chunkSizeMs),\r\n    // FIXME: since the recorder is on a delay line, this math is correct,\r\n    // but it prevents a silence duration of 0 from reporting the full silence detection period\r\n    // Need to rethink how the delay line works to get this to work\r\n    (silenceDurationMs: number) => onTimeUntilClipEndsMs(Math.max(silenceDetectionPeriodMs - (silenceDurationMs + recordingPeriodExtensionMs), 0)),\r\n    () => recorder.stop(),\r\n  );\r\n\r\n  // Cleanup Function\r\n  return () => {\r\n    stopSilenceDetection()\r\n    if (recorder.state === 'recording')\r\n    {\r\n      // If a recording was in progress, get that recording\r\n      // FIXME: prevent trimming end of audio in this case\r\n      recorder.stop()\r\n    }\r\n    audioCtx.close()\r\n    mediaStream.getTracks().forEach(track => track.stop());\r\n    console.log('Ran cleanup function for recording routine')\r\n    //FIXME: this leaks the 'recorder'.  No clue how to resolve this\r\n  }\r\n}\r\n\r\nexport default recordAudioClips;","import { TextField } from '@mui/material';\r\nimport { ChangeEvent, useState } from \"react\";\r\n\r\ntype NumberComponentProps = {\r\n  minValue?: number,\r\n  maxValue?: number,\r\n  onChange?: (validatedInput: number) => void;  // FIXME: is this idiomatic or should it fire an event?\r\n}\r\n\r\nfunction NumberTextField(props: NumberComponentProps) {\r\n  const [inputHasError, setInputHasError] = useState(false);\r\n\r\n  function ingestInput(e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) {\r\n    const inputValue = Number(e.target.value)\r\n    if (\r\n      !e.target.value.trim()  // Input string is whitespace\r\n      || isNaN(inputValue)\r\n      || (props.minValue && inputValue < props.minValue)\r\n      || (props.maxValue && inputValue > props.maxValue)\r\n    ) {\r\n      setInputHasError(true)\r\n    } else {\r\n      setInputHasError(false)\r\n      if (props.onChange) {\r\n        // Pass event through\r\n        props.onChange(inputValue)\r\n      }\r\n    }\r\n  }\r\n\r\n  function prepareHelperText(): string | undefined {\r\n    if (inputHasError) {\r\n      if (props.minValue && props.maxValue) {\r\n        return `Value must be a number between ${props.minValue} and ${props.maxValue}`\r\n      } else if (props.minValue) {\r\n        return `Value must be a number at least ${props.minValue}`\r\n      } else if (props.maxValue) {\r\n        return `Value must be a number at most ${props.maxValue}`\r\n      } else {\r\n        return \"Value must be a number\"\r\n      }\r\n    } else {\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  const { minValue, maxValue, onChange, ...passthroughProps } = props\r\n\r\n  return (\r\n    <TextField\r\n      error={inputHasError}\r\n      onChange={(text) => ingestInput(text)}\r\n      helperText={prepareHelperText()}\r\n      {...passthroughProps}\r\n    />\r\n  )\r\n}\r\n\r\nexport default NumberTextField;\r\n","import {\r\n  Box,\r\n  Checkbox,\r\n  Grid,\r\n  InputAdornment,\r\n  LinearProgress,\r\n  Tooltip,\r\n  FormGroup,\r\n  FormControlLabel,\r\n  TextField,\r\n  Stack,\r\n} from '@mui/material';\r\nimport React, {\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport ToggleButton from './ToggleButton.tsx';\r\nimport AudioDisplay from './AudioDisplay.js';\r\nimport useKeypress from 'react-use-keypress';\r\n\r\nimport recordAudioClips from './Recorder'\r\nimport NumberTextField from './NumberTextField';\r\nimport './App.css'\r\n\r\n// Bug/Feature list:\r\n// TODO: Should NOT trim audio at all when the user invokes \"Stop Recording\"\r\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\r\n// TODO: Status icon when capturing clips\r\n// TODO: (s) adorment on recording timing controls\r\n// TODO: add silence calibration button\r\n\r\nfunction Dictaphone(props) {\r\n  // Set/cleared when the user toggles recording\r\n  const recordingCleanupFunction = useRef();\r\n  // Recording State\r\n  const [isMicrophoneOpen, setMicrophoneOpen] = useState()\r\n  const [timeUntilClipEndsMs, setTimeUntilClipEndsMs] = useState()\r\n  // Preferences\r\n  const [insignificantClipDurationMs, setInsignificantClipDurationMs] = useState(1000)\r\n  const [silenceDetectionPeriodMs, setSilenceDetectionPeriodMs] = useState(3000)\r\n\r\n  useKeypress('r', (event) => {\r\n    if (event.altKey) {\r\n      toggleMicrophoneOpen()\r\n    }\r\n  });\r\n\r\n  const [audioClips, setAudioClips] = useState([])\r\n\r\n  function toggleMicrophoneOpen() {\r\n    if (isMicrophoneOpen) {\r\n      recordingCleanupFunction.current();\r\n      recordingCleanupFunction.current = null;\r\n      setMicrophoneOpen(false)\r\n      setTimeUntilClipEndsMs(0)\r\n    }\r\n    else {\r\n      navigator.mediaDevices.getUserMedia({\r\n        audio: true,\r\n        video: false\r\n      }).then(mediaStream => {\r\n        recordingCleanupFunction.current =\r\n          recordAudioClips(\r\n            mediaStream,\r\n            setTimeUntilClipEndsMs,  // May need to be throttled for performance\r\n            addAudioClip,\r\n            silenceDetectionPeriodMs,\r\n            insignificantClipDurationMs,\r\n          )\r\n      }\r\n      )\r\n      setMicrophoneOpen(true)\r\n    }\r\n  }\r\n\r\n  function addAudioClip(newClip) {\r\n    setAudioClips(clips => [newClip, ...clips])  // Most recent clip first\r\n  }\r\n\r\n  // FIXME: does not distinguish the first time through where no recording takes place\r\n  function getProgressUntilClipEnd() {\r\n    return timeUntilClipEndsMs / silenceDetectionPeriodMs * 100\r\n  }\r\n\r\n  // For debugging state transitions on AudioDisplay\r\n  const [loop, setLoop] = useState(false)  // default to match checkbox\r\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\r\n\r\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\r\n  // only displays the Tooltip when after the first time the Button is clicked\r\n  // This is due to the ToggleButton not containing a Ref since it's a function object\r\n  // Need to either make it a class or find another way around\r\n  return (\r\n    <Box className=\"App\">\r\n      <h2>Muesli Practice Helper</h2>\r\n      <Grid container spacing={2}>\r\n        <Grid item id=\"controls\" xs={5} sm={4} md={3} lg={2}>\r\n          <Stack spacing={2}>\r\n            <Tooltip title=\"Toggle with Alt-R\" arrow>\r\n              <ToggleButton\r\n                enabled={isMicrophoneOpen}\r\n                enableText=\"Start Recording\"\r\n                disableText=\"Stop Recording\"\r\n                onClick={toggleMicrophoneOpen}\r\n              />\r\n            </Tooltip>\r\n\r\n            <p>Mic Open: {String(isMicrophoneOpen)}</p>\r\n            <p>Time until Clip: {String(Math.floor(timeUntilClipEndsMs / 100) / 10)} seconds</p>\r\n            <LinearProgress variant=\"determinate\" value={getProgressUntilClipEnd()} />\r\n\r\n            <TextField\r\n              label=\"Custom Audio File Path\"\r\n              placeholder=\"(debug only)\"\r\n              onChange={(e) => setAudioClips([{ url: e.target.value }])}\r\n            />\r\n\r\n            <NumberTextField\r\n              disabled={isMicrophoneOpen}\r\n              label=\"Cut clip when silent for\"\r\n              placeholder=\"Time...\"\r\n              InputProps={{\r\n                endAdornment: <InputAdornment position=\"end\">s</InputAdornment>,\r\n              }}\r\n              defaultValue={silenceDetectionPeriodMs / 1000}\r\n              minValue={1}\r\n              maxValue={15}\r\n              onChange={(value) => setSilenceDetectionPeriodMs(value * 1000)}\r\n            />\r\n\r\n            <NumberTextField\r\n              disabled={isMicrophoneOpen}\r\n              label=\"Discard clips shorter than\"\r\n              placeholder=\"Time...\"\r\n              InputProps={{\r\n                endAdornment: <InputAdornment position=\"end\">s</InputAdornment>,\r\n              }}\r\n              defaultValue={insignificantClipDurationMs / 1000}\r\n              minValue={0}\r\n              maxValue={5}\r\n              onChange={(value) => setInsignificantClipDurationMs(value * 1000)}\r\n            />\r\n\r\n            <FormGroup>\r\n              <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\r\n              <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\r\n            </FormGroup>\r\n          </Stack>\r\n        </Grid>\r\n        <Grid item id=\"clips\" xs={7} sm={8} md={9} lg={10}>\r\n          <Stack spacing={2}>\r\n            {/* FIXME: Update key with some server-sidable ID instead of the URL?*/}\r\n            {audioClips.map(clip => <AudioDisplay key={clip.url} name={clip.name} audioPath={clip.url} autoplay={autoplay} loop={loop} />)}\r\n          </Stack>\r\n        </Grid>\r\n      </Grid>\r\n    </Box>\r\n  );\r\n}\r\n\r\nexport default Dictaphone;\r\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\r\nimport { CssBaseline } from '@mui/material';\r\nimport './App.css';\r\n\r\n// import LandingPage from './LandingPage.js';\r\nimport Dictaphone from './Dictaphone.js';\r\n\r\nfunction App() {\r\n  const darkTheme = createTheme({\r\n    palette: {\r\n      mode: 'dark',\r\n      background: {\r\n        default: \"#10051a\"\r\n      },\r\n    },\r\n    components: {\r\n      MuiButton: {\r\n        defaultProps: {\r\n          variant: 'outlined',\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return (\r\n    <ThemeProvider theme={darkTheme}>\r\n      <CssBaseline />\r\n      {/* <LandingPage /> */}\r\n      <Dictaphone />\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}