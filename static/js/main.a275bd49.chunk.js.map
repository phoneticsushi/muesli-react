{"version":3,"sources":["ToggleButton.tsx","AudioDisplay.js","Recorder.ts","AudioCapture.ts","NumberTextField.tsx","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","enabled","enableText","disableText","passthroughProps","Button","color","AudioDisplay","ClipRecordingState","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","name","getDuration","ref","onClick","pause","exportBuffersAsWav","buffers","sampleRate","totalLengthInSamples","reduce","sum","array","length","encodedWav","samples","buffer","ArrayBuffer","view","DataView","writeString","setUint32","setUint16","output","offset","input","i","s","Math","max","min","setInt16","writeFloatsAs16BitPCM","encodeWAV","bufferArray","recLengthInSamples","result","Float32Array","set","mergeBuffers","Blob","type","string","setUint8","charCodeAt","recordAudioClips","mediaStream","onTimeUntilClipEndsMs","onNewClip","silenceDetectionPeriodMs","insignificantClipDurationMs","silenceThresholdDbfs","recordingPaddingPeriodMs","Error","samplesPerChunk","audioCtx","AudioContext","sourceNode","createMediaStreamSource","analyserNode","AnalyserNode","minDecibels","captureNode","createScriptProcessor","connect","console","log","samplesPerMs","chunkSizeMs","recordingPaddingPeriodChunks","analyzerFrequencyData","Uint8Array","frequencyBinCount","recordedAudioChunks","recordingState","OpeningPadding","silenceStartTimestamp","pollForSilenceDetection","now","performance","getByteFrequencyData","some","v","Waiting","Recording","silenceDurationMs","publishClip","rotateChunksForNewClip","timeToTrimFromEndMs","numChunksToTrimFromEnd","blob","slice","newClip","randomWords","exactly","wordsPerString","separator","url","window","URL","createObjectURL","onPcmChunk","chunk","push","shift","stopRecording","numChunksForInsignificantClip","close","getTracks","forEach","track","stop","onaudioprocess","audioProcessingEvent","inputBuffer","getChannelData","analysisInterval","setInterval","clearInterval","NumberTextField","useState","inputHasError","setInputHasError","minValue","maxValue","onChange","TextField","error","text","e","inputValue","Number","target","value","trim","isNaN","ingestInput","helperText","Dictaphone","recordingCleanupFunction","isMicrophoneOpen","setMicrophoneOpen","timeUntilClipEndsMs","setTimeUntilClipEndsMs","setInsignificantClipDurationMs","setSilenceDetectionPeriodMs","useKeypress","event","altKey","toggleMicrophoneOpen","audioClips","setAudioClips","navigator","mediaDevices","getUserMedia","audio","video","then","addAudioClip","clips","setLoop","setAutoplay","className","Grid","spacing","item","id","xs","sm","md","lg","Stack","Tooltip","title","arrow","String","floor","LinearProgress","variant","label","placeholder","disabled","InputProps","endAdornment","InputAdornment","position","defaultValue","FormGroup","FormControlLabel","control","Checkbox","checked","map","clip","App","darkTheme","createTheme","mode","background","default","components","MuiButton","defaultProps","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"kYAqBeA,MAbf,SAAsBC,GAC4CA,EAAzDC,QAAyDD,EAAhDE,WAAgDF,EAApCG,YAA5B,IAA4CC,EAA5C,YAAgEJ,EAAhE,GAEA,OACE,cAACK,EAAA,EAAD,yBACEC,MAAON,EAAMC,QAAU,QAAU,WAC7BG,GAFN,aAIGJ,EAAMC,QAAWD,EAAMG,aAAe,UAAcH,EAAME,YAAc,a,yBCkFhEK,IC9FVC,ED8FUD,EA7Ff,SAAsBP,GAAQ,IAAD,EACrBS,EAAQC,cAERC,EAAmBC,mBACnBC,EAAgBD,mBAqEtB,SAASE,IAAQ,IAAD,EACd,UAAAD,EAAcE,eAAd,SAAuBD,OAOzB,OA3EAE,qBACE,WAaE,OATAH,EAAcE,QACZE,IAAWC,OACT,CACEC,UAAWR,EAAiBI,QAC5BK,YAAY,IAKX,WACLP,EAAcE,QAAQM,UACtBR,EAAcE,QAAU,QAG5B,IAGFC,qBACE,WAAO,IAAD,IAGJ,UAAAH,EAAcE,eAAd,SAAuBO,aAAab,EAAMc,QAAQC,QAAQC,MAC1D,UAAAZ,EAAcE,eAAd,SAAuBW,iBAAiBjB,EAAMc,QAAQI,UAAUF,QAElE,CAAChB,EAAMc,QAAQC,QAAQC,KAAMhB,EAAMc,QAAQI,UAAUF,OAGvDT,qBACE,WACuB,IAAD,EAGf,EAHDhB,EAAM4B,SACR,UAAAf,EAAcE,eAAd,SAAuBc,GAAG,QAASf,GAGnC,UAAAD,EAAcE,eAAd,SAAuBe,GAAG,WAG9B,CAAC9B,EAAM4B,WAGTZ,qBACE,WACwB,IAAD,EAEd,EAFHhB,EAAM+B,UACR,UAAAlB,EAAcE,eAAd,SAAuBiB,KAAKhC,EAAM+B,WAElC,UAAAlB,EAAcE,eAAd,SAAuBkB,UAG3B,CAACjC,EAAM+B,YAGTf,qBACE,WACmB,IAAD,EAGX,EAHDhB,EAAMkC,KACR,UAAArB,EAAcE,eAAd,SAAuBc,GAAG,SAAUf,GAGpC,UAAAD,EAAcE,eAAd,SAAuBe,GAAG,YAG9B,CAAC9B,EAAMkC,OAYP,eAACC,EAAA,EAAD,WACE,oDAAuBnC,EAAMoC,MAAQ,aACrC,6CAAgBpC,EAAM+B,aACtB,iDAA2D,KAAvC,UAAAlB,EAAcE,eAAd,eAAuBsB,eAA3C,QACA,qBAAKC,IAAK3B,IACV,cAACN,EAAA,EAAD,CAAQkC,QAASzB,EAAjB,wBACA,cAACT,EAAA,EAAD,CAAQkC,QAXZ,WAAkB,IAAD,EACf,UAAA1B,EAAcE,eAAd,SAAuByB,SAUrB,6B,yBE1FN,SAASC,EAAmBC,EAAyBC,EAAoBC,GAClEA,IAEHA,EAAuBF,EAAQG,QAAQ,SAACC,EAAKC,GAAN,OAAgBD,EAAMC,EAAMC,SAAS,IAE9E,IACMC,EAsDR,SAAmBC,EAAuBP,GACxC,IAAIQ,EAAS,IAAIC,YAAY,GAAsB,EAAjBF,EAAQF,QACtCK,EAAO,IAAIC,SAASH,GAiBxB,OAfAI,EAAYF,EAAM,EAAG,QACrBA,EAAKG,UAAU,EAAG,GAAsB,EAAjBN,EAAQF,QAAY,GAC3CO,EAAYF,EAAM,EAAG,QACrBE,EAAYF,EAAM,GAAI,QACtBA,EAAKG,UAAU,GAAI,IAAI,GACvBH,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKG,UAAU,GAAIb,GAAY,GAC/BU,EAAKG,UAAU,GAAiB,EAAbb,GAAgB,GACnCU,EAAKI,UAAU,GAAI,GAAG,GACtBJ,EAAKI,UAAU,GAAI,IAAI,GACvBF,EAAYF,EAAM,GAAI,QACtBA,EAAKG,UAAU,GAAqB,EAAjBN,EAAQF,QAAY,GA9BzC,SAA+BU,EAAkBC,EAAgBC,GAC/D,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAMZ,OAAQa,IAAKF,GAAU,EAAG,CAClD,IAAIG,EAAIC,KAAKC,KAAK,EAAGD,KAAKE,IAAI,EAAGL,EAAMC,KACvCH,EAAOQ,SAASP,EAAQG,EAAI,EAAQ,MAAJA,EAAiB,MAAJA,GAAY,IA4B3DK,CAAsBd,EAAM,GAAIH,GAEzBG,EAzEYe,CA6BrB,SAAsBC,EAA6BC,GAGjD,IAFA,IAAIC,EAAS,IAAIC,aAAaF,GAC1BX,EAAS,EACJE,EAAI,EAAGA,EAAIQ,EAAYrB,OAAQa,IACtCU,EAAOE,IAAIJ,EAAYR,GAAIF,GAC3BA,GAAUU,EAAYR,GAAGb,OAE3B,OAAOuB,EArCcG,CAAahC,EAASE,GACAD,GAE3C,OADoB,IAAIgC,KAAK,CAAC1B,GAAa,CAAC2B,KAAM,cA+CpD,SAASrB,EAAYG,EAAkBC,EAAgBkB,GACrD,IAAK,IAAIhB,EAAI,EAAGA,EAAIgB,EAAO7B,OAAQa,IACjCH,EAAOoB,SAASnB,EAASE,EAAGgB,EAAOE,WAAWlB,K,SDvD7CrD,K,gCAAAA,E,kBAAAA,E,uBAAAA,M,KA0JUwE,MApJf,SACEC,EACAC,EACAC,EACAC,EACAC,GAIa,IAFbC,EAEY,wDAFY,GACxBC,EACY,uDADe,IAE3B,GAAIH,GAA4BG,EAC9B,MAAM,IAAIC,MAAM,gEAOlB,IAAMC,EAAkB,KAGlBC,EAAW,IAAIC,aAEfC,EAAaF,EAASG,wBAAwBZ,GAC9Ca,EAAe,IAAIC,aAAaL,EAAU,CAAEM,YAAaV,IACzDW,EAAcP,EAASQ,sBAAsBT,EAAiB,EAAG,GAEvEG,EAAWO,QAAQL,GAAcK,QAAQF,GACzCG,QAAQC,IAAI,uBAAwBX,EAAS/C,YAG7C,IAAM2D,EAAeZ,EAAS/C,WAAa,IACrC4D,EAAcd,EAAkBa,EACtCF,QAAQC,IAAI,kBAAmBE,GAC/B,IAAMC,EAA+BjB,EAA2BgB,EAE1DE,EAAwB,IAAIC,WAAWZ,EAAaa,mBACtDC,EAAsC,GACtCC,EAAqCrG,EAAmBsG,eACxDC,EAAoD,KAExD,SAASC,IACP,IAAMC,EAA2BC,YAAYD,MAG7C,GAFAnB,EAAaqB,qBAAqBV,GAE9BI,IAAmBrG,EAAmBsG,eAc1C,GARIL,EAAsBW,MAAK,SAAAC,GAAC,OAAIA,OAClCN,EAAwBE,EACrBJ,IAAmBrG,EAAmB8G,SACvClB,QAAQC,IAAI,kBAEdQ,EAAiBrG,EAAmB+G,WAGR,OAA1BR,EAEF7B,EAAsB,OAGxB,CACE,IAAMsC,EAAoBP,EAAMF,EAChC7B,EAAsBnB,KAAKC,IAAI,EAAGoB,EAA2BoC,IAEzDX,IAAmBrG,EAAmB+G,WAAaC,EAAoBpC,IACzEgB,QAAQC,IAAI,oBACZoB,EAAYD,EAAoBjC,GAChCmC,IACAb,EAAiBrG,EAAmB8G,cAzBtClB,QAAQC,IAAI,wDA8BhB,SAASoB,EAAYE,GACnB,IAAMC,EAAyBD,EAAsBpB,EACrDH,QAAQC,IAAI,oBAAqBO,EAAoB5D,OAAQ,4BAA6B4E,GAC1F,IAEMC,EAAOpF,EAFamE,EAAoBkB,MAAM,EAAGlB,EAAoB5D,OAAS4E,GAEjClC,EAAS/C,YACtDoF,EAAU,CACd3F,KAAM4F,IAAY,CAACC,QAAS,EAAGC,eAAgB,EAAGC,UAAW,MAAM,GACnEC,IAAKC,OAAOC,IAAIC,gBAAgBV,IAElCzB,QAAQC,IAAI,iBAAkB0B,GAC9B5C,EAAU4C,GAGZ,SAASL,IAEPd,EAAsBA,EAAoBkB,MAAMlB,EAAoB5D,OAASwD,EAA8BI,EAAoB5D,QAIjI,SAASwF,EAAWC,GAChB7B,EAAoB8B,KAAKD,GACrB7B,EAAoB5D,OAASwD,IAE3BK,IAAmBrG,EAAmBsG,gBAAkBD,IAAmBrG,EAAmB8G,UAEhGV,EAAoB+B,QACpB9B,EAAiBrG,EAAmB8G,UAc5C,SAASsB,IACPxC,QAAQC,IAAI,uDACZ,IAAMwC,GAAiCxD,EAA8BE,GAA4BgB,EAEjG,GAA8B,OAA1BQ,EACFX,QAAQC,IAAI,uEACP,GAAIO,EAAoB5D,QAAU6F,EAEvCzC,QAAQC,IAAI,kDAAmDO,EAAoB5D,OAAQ,KAAM6F,OAC5F,CAELpB,EAD0BP,YAAYD,MAAQF,EACdxB,GAGlCG,EAASoD,QACT7D,EAAY8D,YAAYC,SAAQ,SAAAC,GAAK,OAAIA,EAAMC,UAxBjDjD,EAAYkD,eAAiB,SAASC,GAMpCZ,EALoBY,EAAqBC,YAIXC,eAAe,KAsB/ClD,QAAQC,IAAI,wBACZ,IAAMkD,EAAmBC,YAAYxC,EAAyB,KAG9D,OAAO,WACLyC,cAAcF,GACdX,IACAxC,QAAQC,IAAI,gD,qCE/FDqD,MAjDf,SAAyB1J,GACvB,MAA0C2J,oBAAS,GAAnD,mBAAOC,EAAP,KAAsBC,EAAtB,KAoC8D7J,EAAtD8J,SAAsD9J,EAA5C+J,SAA4C/J,EAAlCgK,SAA5B,IAAyC5J,EAAzC,YAA8DJ,EAA9D,GAEA,OACE,cAACiK,EAAA,EAAD,aACEC,MAAON,EACPI,SAAU,SAACG,GAAD,OAvCd,SAAqBC,GACnB,IAAMC,EAAaC,OAAOF,EAAEG,OAAOC,QAEhCJ,EAAEG,OAAOC,MAAMC,QACbC,MAAML,IACLrK,EAAM8J,UAAYO,EAAarK,EAAM8J,UACrC9J,EAAM+J,UAAYM,EAAarK,EAAM+J,SAEzCF,GAAiB,IAEjBA,GAAiB,GACb7J,EAAMgK,UAERhK,EAAMgK,SAASK,IA0BGM,CAAYR,IAChCS,WArBEhB,EACE5J,EAAM8J,UAAY9J,EAAM+J,SACpB,kCAAN,OAAyC/J,EAAM8J,SAA/C,gBAA+D9J,EAAM+J,UAC5D/J,EAAM8J,SACT,mCAAN,OAA0C9J,EAAM8J,UACvC9J,EAAM+J,SACT,kCAAN,OAAyC/J,EAAM+J,UAExC,8BAGT,GAWI3J,KC+GKyK,MAtIf,SAAoB7K,GAElB,IAAM8K,EAA2BlK,mBAEjC,EAA8C+I,qBAA9C,mBAAOoB,EAAP,KAAyBC,EAAzB,KACA,EAAsDrB,qBAAtD,mBAAOsB,EAAP,KAA4BC,EAA5B,KAEA,EAAsEvB,mBAAS,KAA/E,mBAAOtE,EAAP,KAAoC8F,EAApC,KACA,EAAgExB,mBAAS,KAAzE,mBAAOvE,EAAP,KAAiCgG,EAAjC,KAEAC,YAAY,KAAK,SAACC,GACZA,EAAMC,QACRC,OAIJ,MAAoC7B,mBAAS,IAA7C,mBAAO8B,EAAP,KAAmBC,EAAnB,KAEA,SAASF,IACHT,GACFD,EAAyB/J,UACzB+J,EAAyB/J,QAAU,KACnCiK,GAAkB,GAClBE,EAAuB,KAGvBS,UAAUC,aAAaC,aAAa,CAClCC,OAAO,EACPC,OAAO,IACNC,MAAK,SAAA/G,GACN6F,EAAyB/J,QACvBiE,EACEC,EACAiG,EACAe,EACA7G,EACAC,MAIN2F,GAAkB,IAItB,SAASiB,EAAalE,GACpB2D,GAAc,SAAAQ,GAAK,OAAKnE,GAAL,mBAAiBmE,OAStC,MAAwBvC,oBAAS,GAAjC,mBAAOzH,EAAP,KAAaiK,EAAb,KACA,EAAgCxC,oBAAS,GAAzC,mBAAO/H,EAAP,KAAiBwK,EAAjB,KAMA,OACE,eAACjK,EAAA,EAAD,CAAKkK,UAAU,MAAf,UACE,wDACA,eAACC,EAAA,EAAD,CAAMnL,WAAS,EAACoL,QAAS,EAAzB,UACE,cAACD,EAAA,EAAD,CAAME,MAAI,EAACC,GAAG,WAAWC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAlD,SACE,eAACC,EAAA,EAAD,CAAOP,QAAS,EAAhB,UACE,cAACQ,EAAA,EAAD,CAASC,MAAM,oBAAoBC,OAAK,EAAxC,SACE,cAAC,EAAD,CACEhN,QAAS8K,EACT7K,WAAW,kBACXC,YAAY,iBACZoC,QAASiJ,MAIb,2CAAc0B,OAAOnC,MACrB,kDAAqBmC,OAAOnJ,KAAKoJ,MAAMlC,EAAsB,KAAO,IAApE,cAGA,cAACmC,EAAA,EAAD,CACEC,QAAQ,cACR7C,MAhCHS,EAAsB7F,EAA2B,MAmChD,cAAC6E,EAAA,EAAD,CACEqD,MAAM,yBACNC,YAAY,eACZvD,SAAU,SAACI,GAAD,OAAOsB,EAAc,CAAC,CAAEtD,IAAKgC,EAAEG,OAAOC,YAGlD,cAAC,EAAD,CACEgD,SAAUzC,EACVuC,MAAM,2BACNC,YAAY,UACZE,WAAY,CACVC,aAAc,cAACC,EAAA,EAAD,CAAgBC,SAAS,MAAzB,gBAEhBC,aAAczI,EAA2B,IACzC0E,SAAU,EACVC,SAAU,GACVC,SAAU,SAACQ,GAAD,OAAWY,EAAoC,IAARZ,MAGnD,cAAC,EAAD,CACEgD,SAAUzC,EACVuC,MAAM,6BACNC,YAAY,UACZE,WAAY,CACVC,aAAc,cAACC,EAAA,EAAD,CAAgBC,SAAS,MAAzB,gBAEhBC,aAAcxI,EAA8B,IAC5CyE,SAAU,EACVC,SAAU,EACVC,SAAU,SAACQ,GAAD,OAAWW,EAAuC,IAARX,MAGtD,eAACsD,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CAAkBC,QAAS,cAACC,EAAA,EAAD,CAAUjE,SAAU,SAACI,GAAD,OAAO+B,EAAQ/B,EAAEG,OAAO2D,YAAcZ,MAAM,SAC3F,cAACS,EAAA,EAAD,CAAkBC,QAAS,cAACC,EAAA,EAAD,CAAUjE,SAAU,SAACI,GAAD,OAAOgC,EAAYhC,EAAEG,OAAO2D,YAAcZ,MAAM,qBAIrG,cAAChB,EAAA,EAAD,CAAME,MAAI,EAACC,GAAG,QAAQC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAA/C,SACE,cAACC,EAAA,EAAD,CAAOP,QAAS,EAAhB,SAEGd,EAAW0C,KAAI,SAAAC,GAAI,OAAI,cAAC,EAAD,CAA6BhM,KAAMgM,EAAKhM,KAAML,UAAWqM,EAAKhG,IAAKxG,SAAUA,EAAUM,KAAMA,GAA1EkM,EAAKhG,mBC3H7CiG,MA1Bf,WACE,IAAMC,EAAYC,YAAY,CAC5BhN,QAAS,CACPiN,KAAM,OACNC,WAAY,CACVC,QAAS,YAGbC,WAAY,CACVC,UAAW,CACTC,aAAc,CACZxB,QAAS,gBAMjB,OACE,eAACyB,EAAA,EAAD,CAAerO,MAAO6N,EAAtB,UACE,cAACS,EAAA,EAAD,IAEA,cAAC,EAAD,QChBSC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBlD,MAAK,YAAkD,IAA/CmD,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,K","file":"static/js/main.a275bd49.chunk.js","sourcesContent":["import { Button } from '@mui/material';\r\n\r\ntype ToggleButtonProps = {\r\n  enabled?: boolean,\r\n  enableText?: string,\r\n  disableText?: string\r\n}\r\n\r\nfunction ToggleButton(props: ToggleButtonProps) {\r\n  const {enabled, enableText, disableText, ...passthroughProps} = props\r\n\r\n  return (\r\n    <Button\r\n      color={props.enabled ? \"error\" : \"success\"}\r\n      {...passthroughProps}\r\n    >\r\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\r\n    </Button>\r\n  );\r\n}\r\n\r\nexport default ToggleButton;\r\n","import { useEffect, useRef } from \"react\";\r\nimport { Box, Button } from '@mui/material';\r\nimport WaveSurfer from \"wavesurfer.js\";\r\nimport { useTheme } from '@mui/material/styles';\r\n\r\nfunction AudioDisplay(props) {\r\n  const theme = useTheme()\r\n\r\n  const waveSurferDomRef = useRef();\r\n  const waveSurferRef = useRef();\r\n\r\n  useEffect(\r\n    () => {\r\n      // WaveSurfer requires the DOM in which it's rendered\r\n      // to be loaded on the page before calling its create function.\r\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\r\n      waveSurferRef.current =\r\n        WaveSurfer.create(\r\n          {\r\n            container: waveSurferDomRef.current,\r\n            responsive: true,\r\n          }\r\n        )\r\n      \r\n      // returned function will be called on component unmount\r\n      return () => {\r\n        waveSurferRef.current.destroy()\r\n        waveSurferRef.current = null\r\n      }\r\n    },\r\n    []   // <-- empty dependency array implies 'run once'\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      // Setting these values here instead of during WaveSurfer.create()\r\n      // so component remains fully responsive\r\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\r\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\r\n    },\r\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.autoplay) {\r\n        waveSurferRef.current?.on('ready', play);\r\n      }\r\n      else {\r\n        waveSurferRef.current?.un('ready');\r\n      }\r\n    },\r\n    [props.autoplay],\r\n  )\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.audioPath) {\r\n        waveSurferRef.current?.load(props.audioPath);\r\n      } else {\r\n        waveSurferRef.current?.empty()\r\n      }\r\n    },\r\n    [props.audioPath],\r\n  );\r\n\r\n  useEffect(\r\n    () => {\r\n      if (props.loop) {\r\n        waveSurferRef.current?.on('finish', play);\r\n      }\r\n      else {\r\n        waveSurferRef.current?.un('finish');\r\n      }\r\n    },\r\n    [props.loop]\r\n  );\r\n\r\n  function play() {\r\n    waveSurferRef.current?.play();\r\n  }\r\n\r\n  function pause() {\r\n    waveSurferRef.current?.pause();\r\n  }\r\n\r\n  return (\r\n    <Box>\r\n      <h2>AudioDisplay WIP: {props.name || \"No Name\"}</h2>\r\n      <p>Audio Path: {props.audioPath}</p>\r\n      <p>Audio Duration: {waveSurferRef.current?.getDuration() * 1000}ms</p>{/* FIXME: duration not available until later; use state */}\r\n      <div ref={waveSurferDomRef}></div>\r\n      <Button onClick={play}>Play Audio</Button>\r\n      <Button onClick={pause}>Pause Audio</Button>\r\n    </Box>\r\n  );\r\n}\r\n\r\nexport default AudioDisplay;\r\n","import randomWords from 'random-words';\r\nimport { MuesliAudioClip } from './Types';\r\nimport { exportBuffersAsWav } from './AudioCapture'\r\n\r\nenum ClipRecordingState {\r\n  OpeningPadding = \"OpeningPadding\",\r\n  Waiting = \"Waiting\",\r\n  Recording = \"Recording\",\r\n}\r\n\r\nfunction recordAudioClips(\r\n  mediaStream: MediaStream,\r\n  onTimeUntilClipEndsMs: (timeUntilClipEndsMs: number) => void,\r\n  onNewClip: (clip: MuesliAudioClip) => void,\r\n  silenceDetectionPeriodMs: number,\r\n  insignificantClipDurationMs: number,  // Clips shorter than this won't be saved\r\n  // FIXME: move magic numbers into UI controls\r\n  silenceThresholdDbfs = -60,\r\n  recordingPaddingPeriodMs = 500,  // How much audio is retained in each clip before and after silence\r\n): () => void {\r\n  if (silenceDetectionPeriodMs <= recordingPaddingPeriodMs) {\r\n    throw new Error(\"Silence detection period must be greater than padding period\");\r\n  }\r\n\r\n  // Since operations are done by chunk,\r\n  // this is a tradeoff between trimming precision and performance.\r\n  // createScriptProcessor() requires that this is a power of 2.\r\n  // FIXME: do math in samples rather than chunks\r\n  const samplesPerChunk = 2048\r\n\r\n  // Set up AudioContext\r\n  const audioCtx = new AudioContext();\r\n\r\n  const sourceNode = audioCtx.createMediaStreamSource(mediaStream);\r\n  const analyserNode = new AnalyserNode(audioCtx, { minDecibels: silenceThresholdDbfs });\r\n  const captureNode = audioCtx.createScriptProcessor(samplesPerChunk, 2, 0);\r\n\r\n  sourceNode.connect(analyserNode).connect(captureNode);\r\n  console.log('Source Sample Rate: ', audioCtx.sampleRate)\r\n\r\n  // Compute remaining time periods\r\n  const samplesPerMs = audioCtx.sampleRate / 1000\r\n  const chunkSizeMs = samplesPerChunk / samplesPerMs;\r\n  console.log('Chunk Size Ms: ', chunkSizeMs)\r\n  const recordingPaddingPeriodChunks = recordingPaddingPeriodMs / chunkSizeMs;\r\n\r\n  const analyzerFrequencyData = new Uint8Array(analyserNode.frequencyBinCount);  // Will be clobbered every time the frequency analyzer runs\r\n  let recordedAudioChunks: Float32Array[] = []\r\n  let recordingState: ClipRecordingState = ClipRecordingState.OpeningPadding;\r\n  let silenceStartTimestamp: DOMHighResTimeStamp | null = null\r\n  \r\n  function pollForSilenceDetection() {\r\n    const now: DOMHighResTimeStamp = performance.now()\r\n    analyserNode.getByteFrequencyData(analyzerFrequencyData); // get current data\r\n\r\n    if (recordingState === ClipRecordingState.OpeningPadding)\r\n    {\r\n      console.log('Skipping silence detection while waiting for padding')\r\n      return;\r\n    }\r\n\r\n    if (analyzerFrequencyData.some(v => v)) { // if there is data above the given db limit\r\n      silenceStartTimestamp = now;\r\n      if(recordingState === ClipRecordingState.Waiting){\r\n        console.log(\"Detected Audio\")\r\n      }\r\n      recordingState = ClipRecordingState.Recording;\r\n    }\r\n\r\n    if (silenceStartTimestamp === null)\r\n    {\r\n      onTimeUntilClipEndsMs(0);\r\n    }\r\n    else\r\n    {\r\n      const silenceDurationMs = now - silenceStartTimestamp\r\n      onTimeUntilClipEndsMs(Math.max(0, silenceDetectionPeriodMs - silenceDurationMs))  // Allow React to update the UI\r\n\r\n      if (recordingState === ClipRecordingState.Recording && silenceDurationMs > silenceDetectionPeriodMs) {\r\n        console.log(\"Detected Silence\")\r\n        publishClip(silenceDurationMs - recordingPaddingPeriodMs)\r\n        rotateChunksForNewClip()\r\n        recordingState = ClipRecordingState.Waiting\r\n      }\r\n    }\r\n  }\r\n\r\n  function publishClip(timeToTrimFromEndMs: number) {\r\n    const numChunksToTrimFromEnd = timeToTrimFromEndMs / chunkSizeMs;\r\n    console.log(\"Converting Audio:\", recordedAudioChunks.length, \"chunks available, trmming\", numChunksToTrimFromEnd)\r\n    const slicedAudioChunks = recordedAudioChunks.slice(0, recordedAudioChunks.length - numChunksToTrimFromEnd);\r\n  // FIXME: consider encoding the audio somehow after a clip is created rather than using WAV?\r\n    const blob = exportBuffersAsWav(slicedAudioChunks, audioCtx.sampleRate)\r\n    const newClip = {\r\n      name: randomWords({exactly: 1, wordsPerString: 2, separator: '-'})[0],  // Returns array for some reason\r\n      url: window.URL.createObjectURL(blob)\r\n    }\r\n    console.log(\"Generated clip\", newClip);\r\n    onNewClip(newClip)\r\n  }\r\n\r\n  function rotateChunksForNewClip() {\r\n    // Prepare for next recording by keeping most recent audio to use as padding for the next clip\r\n    recordedAudioChunks = recordedAudioChunks.slice(recordedAudioChunks.length - recordingPaddingPeriodChunks, recordedAudioChunks.length);\r\n  }\r\n\r\n  \r\n  function onPcmChunk(chunk: Float32Array) {\r\n      recordedAudioChunks.push(chunk);\r\n      if (recordedAudioChunks.length > recordingPaddingPeriodChunks)\r\n      {\r\n        if (recordingState === ClipRecordingState.OpeningPadding || recordingState === ClipRecordingState.Waiting)\r\n        {\r\n          recordedAudioChunks.shift()\r\n          recordingState = ClipRecordingState.Waiting\r\n        }\r\n      }\r\n  }\r\n\r\n  captureNode.onaudioprocess = function(audioProcessingEvent) {\r\n    const inputBuffer = audioProcessingEvent.inputBuffer;\r\n    \r\n    //FIXME: handle more than first channel\r\n    // for (var channel = 0; channel < inputBuffer.numberOfChannels; channel++) {\r\n    const inputData = inputBuffer.getChannelData(0);\r\n    onPcmChunk(inputData)\r\n  }\r\n\r\n  function stopRecording() {\r\n    console.log('Recorder has been stopped; publishing final clip...')\r\n    const numChunksForInsignificantClip = (insignificantClipDurationMs + recordingPaddingPeriodMs) / chunkSizeMs;\r\n\r\n    if (silenceStartTimestamp === null) {\r\n      console.log(\"Skipping final clip publish as silence has never been detected\")\r\n    } else if (recordedAudioChunks.length <= numChunksForInsignificantClip) {\r\n      // Drop any audio in the buffer as it's too short to be an actual recording\r\n      console.log(\"Skipping final clip publish as number of chunks\", recordedAudioChunks.length, \"<=\", numChunksForInsignificantClip)\r\n    } else {\r\n      const silenceDurationMs = performance.now() - silenceStartTimestamp;\r\n      publishClip(silenceDurationMs - recordingPaddingPeriodMs);\r\n    }\r\n\r\n    audioCtx.close()\r\n    mediaStream.getTracks().forEach(track => track.stop());\r\n  }\r\n\r\n  console.log('Starting Recorder...')\r\n  const analysisInterval = setInterval(pollForSilenceDetection, 100);  // Arbitrary delay\r\n\r\n  // Cleanup Function\r\n  return () => {\r\n    clearInterval(analysisInterval)\r\n    stopRecording()\r\n    console.log('Ran cleanup function for recording routine')\r\n    //FIXME: getting some exceptions related to calling \"process\" that may be related to this - not sure yet\r\n  }\r\n}\r\n\r\nexport default recordAudioClips;","// Adapted from https://github.com/awslabs/aws-lex-browser-audio-capture/blob/master/lib/worker.js\r\n\r\n//FIXME: make support multiple channels\r\nfunction exportBuffersAsWav(buffers: Float32Array[], sampleRate: number, totalLengthInSamples?: number): Blob {\r\n  if (!totalLengthInSamples)\r\n  {\r\n    totalLengthInSamples = buffers.reduce(((sum, array) => sum + array.length), 0);\r\n  }\r\n  const mergedBuffer = mergeBuffers(buffers, totalLengthInSamples);\r\n  const encodedWav = encodeWAV(mergedBuffer, sampleRate)\r\n  const wavFileBlob = new Blob([encodedWav], {type: 'audio/wav'});\r\n  return wavFileBlob;\r\n}\r\n\r\nfunction downsampleBuffer(buffer: Float32Array, inputSampleRate: number, targetSampleRate: number): Float32Array {\r\n  if (inputSampleRate === targetSampleRate) {\r\n    return buffer;\r\n  }\r\n  var sampleRateRatio = inputSampleRate / targetSampleRate;\r\n  var newLength = Math.round(buffer.length / sampleRateRatio);\r\n  var result = new Float32Array(newLength);\r\n  var offsetResult = 0;\r\n  var offsetBuffer = 0;\r\n  while (offsetResult < result.length) {\r\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\r\n    var accum = 0,\r\n      count = 0;\r\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\r\n      accum += buffer[i];\r\n      count++;\r\n    }\r\n    result[offsetResult] = accum / count;\r\n    offsetResult++;\r\n    offsetBuffer = nextOffsetBuffer;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction mergeBuffers(bufferArray: Float32Array[], recLengthInSamples: number): Float32Array {\r\n  var result = new Float32Array(recLengthInSamples);\r\n  var offset = 0;\r\n  for (var i = 0; i < bufferArray.length; i++) {\r\n    result.set(bufferArray[i], offset);\r\n    offset += bufferArray[i].length;\r\n  }\r\n  return result;\r\n}\r\n\r\n// Appends to \"output\"\r\nfunction writeFloatsAs16BitPCM(output: DataView, offset: number, input: Float32Array) {\r\n  for (var i = 0; i < input.length; i++, offset += 2) {\r\n    var s = Math.max(-1, Math.min(1, input[i]));\r\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\r\n  }\r\n}\r\n\r\n// Appends to \"output\"\r\nfunction writeString(output: DataView, offset: number, string: String) {\r\n  for (var i = 0; i < string.length; i++) {\r\n    output.setUint8(offset + i, string.charCodeAt(i));\r\n  }\r\n}\r\n\r\nfunction encodeWAV(samples: Float32Array, sampleRate: number): DataView {\r\n  var buffer = new ArrayBuffer(44 + samples.length * 2);\r\n  var view = new DataView(buffer);\r\n\r\n  writeString(view, 0, 'RIFF');\r\n  view.setUint32(4, 32 + samples.length * 2, true);\r\n  writeString(view, 8, 'WAVE');\r\n  writeString(view, 12, 'fmt ');\r\n  view.setUint32(16, 16, true);\r\n  view.setUint16(20, 1, true);\r\n  view.setUint16(22, 1, true);\r\n  view.setUint32(24, sampleRate, true);\r\n  view.setUint32(28, sampleRate * 2, true);\r\n  view.setUint16(32, 2, true);\r\n  view.setUint16(34, 16, true);\r\n  writeString(view, 36, 'data');\r\n  view.setUint32(40, samples.length * 2, true);\r\n  writeFloatsAs16BitPCM(view, 44, samples);\r\n\r\n  return view;\r\n}\r\n\r\nexport { exportBuffersAsWav, downsampleBuffer, mergeBuffers };\r\n","import { TextField } from '@mui/material';\r\nimport { ChangeEvent, useState } from \"react\";\r\n\r\ntype NumberComponentProps = {\r\n  minValue?: number,\r\n  maxValue?: number,\r\n  onChange?: (validatedInput: number) => void;  // FIXME: is this idiomatic or should it fire an event?\r\n}\r\n\r\nfunction NumberTextField(props: NumberComponentProps) {\r\n  const [inputHasError, setInputHasError] = useState(false);\r\n\r\n  function ingestInput(e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) {\r\n    const inputValue = Number(e.target.value)\r\n    if (\r\n      !e.target.value.trim()  // Input string is whitespace\r\n      || isNaN(inputValue)\r\n      || (props.minValue && inputValue < props.minValue)\r\n      || (props.maxValue && inputValue > props.maxValue)\r\n    ) {\r\n      setInputHasError(true)\r\n    } else {\r\n      setInputHasError(false)\r\n      if (props.onChange) {\r\n        // Pass event through\r\n        props.onChange(inputValue)\r\n      }\r\n    }\r\n  }\r\n\r\n  function prepareHelperText(): string | undefined {\r\n    if (inputHasError) {\r\n      if (props.minValue && props.maxValue) {\r\n        return `Value must be a number between ${props.minValue} and ${props.maxValue}`\r\n      } else if (props.minValue) {\r\n        return `Value must be a number at least ${props.minValue}`\r\n      } else if (props.maxValue) {\r\n        return `Value must be a number at most ${props.maxValue}`\r\n      } else {\r\n        return \"Value must be a number\"\r\n      }\r\n    } else {\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  const { minValue, maxValue, onChange, ...passthroughProps } = props\r\n\r\n  return (\r\n    <TextField\r\n      error={inputHasError}\r\n      onChange={(text) => ingestInput(text)}\r\n      helperText={prepareHelperText()}\r\n      {...passthroughProps}\r\n    />\r\n  )\r\n}\r\n\r\nexport default NumberTextField;\r\n","import {\r\n  Box,\r\n  Checkbox,\r\n  Grid,\r\n  InputAdornment,\r\n  LinearProgress,\r\n  Tooltip,\r\n  FormGroup,\r\n  FormControlLabel,\r\n  TextField,\r\n  Stack,\r\n} from '@mui/material';\r\nimport React, {\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport ToggleButton from './ToggleButton.tsx';\r\nimport AudioDisplay from './AudioDisplay.js';\r\nimport useKeypress from 'react-use-keypress';\r\n\r\nimport recordAudioClips from './Recorder'\r\nimport NumberTextField from './NumberTextField';\r\nimport './App.css'\r\n\r\n// Bug/Feature list:\r\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\r\n// TODO: Status icon when capturing clips\r\n// TODO: (s) adorment on recording timing controls\r\n// TODO: add silence calibration button\r\n\r\nfunction Dictaphone(props) {\r\n  // Set/cleared when the user toggles recording\r\n  const recordingCleanupFunction = useRef();\r\n  // Recording State\r\n  const [isMicrophoneOpen, setMicrophoneOpen] = useState()\r\n  const [timeUntilClipEndsMs, setTimeUntilClipEndsMs] = useState()\r\n  // Preferences\r\n  const [insignificantClipDurationMs, setInsignificantClipDurationMs] = useState(1000)\r\n  const [silenceDetectionPeriodMs, setSilenceDetectionPeriodMs] = useState(3000)\r\n\r\n  useKeypress('r', (event) => {\r\n    if (event.altKey) {\r\n      toggleMicrophoneOpen()\r\n    }\r\n  });\r\n\r\n  const [audioClips, setAudioClips] = useState([])\r\n\r\n  function toggleMicrophoneOpen() {\r\n    if (isMicrophoneOpen) {\r\n      recordingCleanupFunction.current();\r\n      recordingCleanupFunction.current = null;\r\n      setMicrophoneOpen(false)\r\n      setTimeUntilClipEndsMs(0)\r\n    }\r\n    else {\r\n      navigator.mediaDevices.getUserMedia({\r\n        audio: true,\r\n        video: false\r\n      }).then(mediaStream => {\r\n        recordingCleanupFunction.current =\r\n          recordAudioClips(\r\n            mediaStream,\r\n            setTimeUntilClipEndsMs,  // May need to be throttled for performance\r\n            addAudioClip,\r\n            silenceDetectionPeriodMs,\r\n            insignificantClipDurationMs,\r\n          )\r\n      }\r\n      )\r\n      setMicrophoneOpen(true)\r\n    }\r\n  }\r\n\r\n  function addAudioClip(newClip) {\r\n    setAudioClips(clips => [newClip, ...clips])  // Most recent clip first\r\n  }\r\n\r\n  // FIXME: does not distinguish the first time through where no recording takes place\r\n  function getProgressUntilClipEnd() {\r\n    return timeUntilClipEndsMs / silenceDetectionPeriodMs * 100\r\n  }\r\n\r\n  // For debugging state transitions on AudioDisplay\r\n  const [loop, setLoop] = useState(false)  // default to match checkbox\r\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\r\n\r\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\r\n  // only displays the Tooltip when after the first time the Button is clicked\r\n  // This is due to the ToggleButton not containing a Ref since it's a function object\r\n  // Need to either make it a class or find another way around\r\n  return (\r\n    <Box className=\"App\">\r\n      <h2>Muesli Practice Helper</h2>\r\n      <Grid container spacing={2}>\r\n        <Grid item id=\"controls\" xs={5} sm={4} md={3} lg={2}>\r\n          <Stack spacing={2}>\r\n            <Tooltip title=\"Toggle with Alt-R\" arrow>\r\n              <ToggleButton\r\n                enabled={isMicrophoneOpen}\r\n                enableText=\"Start Recording\"\r\n                disableText=\"Stop Recording\"\r\n                onClick={toggleMicrophoneOpen}\r\n              />\r\n            </Tooltip>\r\n\r\n            <p>Mic Open: {String(isMicrophoneOpen)}</p>\r\n            <p>Time until Clip: {String(Math.floor(timeUntilClipEndsMs / 100) / 10)} seconds</p>\r\n\r\n            {/* FIXME: flip horizontally? */}\r\n            <LinearProgress\r\n              variant=\"determinate\"\r\n              value={getProgressUntilClipEnd()}\r\n            />\r\n\r\n            <TextField\r\n              label=\"Custom Audio File Path\"\r\n              placeholder=\"(debug only)\"\r\n              onChange={(e) => setAudioClips([{ url: e.target.value }])}\r\n            />\r\n\r\n            <NumberTextField\r\n              disabled={isMicrophoneOpen}\r\n              label=\"Cut clip when silent for\"\r\n              placeholder=\"Time...\"\r\n              InputProps={{\r\n                endAdornment: <InputAdornment position=\"end\">s</InputAdornment>,\r\n              }}\r\n              defaultValue={silenceDetectionPeriodMs / 1000}\r\n              minValue={1}\r\n              maxValue={15}\r\n              onChange={(value) => setSilenceDetectionPeriodMs(value * 1000)}\r\n            />\r\n\r\n            <NumberTextField\r\n              disabled={isMicrophoneOpen}\r\n              label=\"Discard clips shorter than\"\r\n              placeholder=\"Time...\"\r\n              InputProps={{\r\n                endAdornment: <InputAdornment position=\"end\">s</InputAdornment>,\r\n              }}\r\n              defaultValue={insignificantClipDurationMs / 1000}\r\n              minValue={0}\r\n              maxValue={5}\r\n              onChange={(value) => setInsignificantClipDurationMs(value * 1000)}\r\n            />\r\n\r\n            <FormGroup>\r\n              <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\r\n              <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\r\n            </FormGroup>\r\n          </Stack>\r\n        </Grid>\r\n        <Grid item id=\"clips\" xs={7} sm={8} md={9} lg={10}>\r\n          <Stack spacing={2}>\r\n            {/* FIXME: Update key with some server-sidable ID instead of the URL?*/}\r\n            {audioClips.map(clip => <AudioDisplay key={clip.url} name={clip.name} audioPath={clip.url} autoplay={autoplay} loop={loop} />)}\r\n          </Stack>\r\n        </Grid>\r\n      </Grid>\r\n    </Box>\r\n  );\r\n}\r\n\r\nexport default Dictaphone;\r\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\r\nimport { CssBaseline } from '@mui/material';\r\nimport './App.css';\r\n\r\n// import LandingPage from './LandingPage.js';\r\nimport Dictaphone from './Dictaphone.js';\r\n\r\nfunction App() {\r\n  const darkTheme = createTheme({\r\n    palette: {\r\n      mode: 'dark',\r\n      background: {\r\n        default: \"#10051a\"\r\n      },\r\n    },\r\n    components: {\r\n      MuiButton: {\r\n        defaultProps: {\r\n          variant: 'outlined',\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return (\r\n    <ThemeProvider theme={darkTheme}>\r\n      <CssBaseline />\r\n      {/* <LandingPage /> */}\r\n      <Dictaphone />\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}