{"version":3,"sources":["ToggleButton.tsx","AudioDisplay.js","Recorder.ts","NumberTextField.tsx","Dictaphone.js","App.js","reportWebVitals.js","index.js"],"names":["ToggleButton","props","enabled","enableText","disableText","passthroughProps","Button","color","AudioDisplay","theme","useTheme","waveSurferDomRef","useRef","waveSurferRef","play","current","useEffect","WaveSurfer","create","container","responsive","destroy","setWaveColor","palette","primary","dark","setProgressColor","secondary","autoplay","on","un","audioPath","load","empty","loop","Box","name","getDuration","ref","onClick","pause","detectSilence","audioCtx","sourceAudioNode","silence_delay_ms","min_decibels","onSoundStart","onSoundEnd","analyserNode","AnalyserNode","minDecibels","connect","data","Uint8Array","frequencyBinCount","silence_start","performance","now","activelyRecording","getByteFrequencyData","some","v","console","log","analysisInterval","setInterval","clearInterval","recordAudioClips","mediaStream","onNewClip","silenceDetectionPeriodMs","insignificantClipDurationMs","silenceThresholdDbfs","recordingPeriodExtensionMs","chunkSizeMs","numChunksToTrimFromRecordingEnd","numChunksForInsignificantClip","AudioContext","sourceNode","createMediaStreamSource","delayNode","DelayNode","delayTime","maxDelayTime","destinationNode","createMediaStreamDestination","recorder","MediaRecorder","stream","chunks","ondataavailable","e","push","onstop","length","blob","Blob","slice","newClip","randomWords","exactly","wordsPerString","separator","url","window","URL","createObjectURL","stopSilenceDetection","start","stop","state","close","getTracks","forEach","track","NumberTextField","useState","inputHasError","setInputHasError","minValue","maxValue","onChange","TextField","error","text","inputValue","Number","target","value","trim","isNaN","ingestInput","helperText","Dictaphone","recordingCleanupFunction","isRecording","setRecordingState","setInsignificantClipDurationMs","setSilenceDetectionPeriodMs","useKeypress","event","altKey","toggleRecording","audioClips","setAudioClips","navigator","mediaDevices","getUserMedia","audio","video","then","addAudioClip","clips","setLoop","setAutoplay","className","Grid","spacing","item","id","xs","sm","md","lg","Stack","Tooltip","title","arrow","label","placeholder","disabled","defaultValue","FormGroup","FormControlLabel","control","Checkbox","checked","map","clip","App","darkTheme","createTheme","mode","background","default","components","MuiButton","defaultProps","variant","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.03659a85.chunk.js","sourcesContent":["import { Button } from '@mui/material';\n\ntype ToggleButtonProps = {\n  enabled?: boolean,\n  enableText?: string,\n  disableText?: string\n}\n\nfunction ToggleButton(props: ToggleButtonProps) {\n  const {enabled, enableText, disableText, ...passthroughProps} = props\n\n  return (\n    <Button\n      color={props.enabled ? \"error\" : \"success\"}\n      {...passthroughProps}\n    >\n      {props.enabled ? (props.disableText || \"Disable\") : (props.enableText || \"Enable\")}\n    </Button>\n  );\n}\n\nexport default ToggleButton;\n","import { useEffect, useRef } from \"react\";\nimport { Box, Button } from '@mui/material';\nimport WaveSurfer from \"wavesurfer.js\";\nimport { useTheme } from '@mui/material/styles';\n\nfunction AudioDisplay(props) {\n  const theme = useTheme()\n\n  const waveSurferDomRef = useRef();\n  const waveSurferRef = useRef();\n\n  useEffect(\n    () => {\n      // WaveSurfer requires the DOM in which it's rendered\n      // to be loaded on the page before calling its create function.\n      // To compensate, we initialize the WaveSurfer object once as a side-effect\n      waveSurferRef.current =\n        WaveSurfer.create(\n          {\n            container: waveSurferDomRef.current,\n            responsive: true,\n          }\n        )\n      \n      // returned function will be called on component unmount\n      return () => {\n        waveSurferRef.current.destroy()\n        waveSurferRef.current = null\n      }\n    },\n    []   // <-- empty dependency array implies 'run once'\n  );\n\n  useEffect(\n    () => {\n      // Setting these values here instead of during WaveSurfer.create()\n      // so component remains fully responsive\n      waveSurferRef.current?.setWaveColor(theme.palette.primary.dark)\n      waveSurferRef.current?.setProgressColor(theme.palette.secondary.dark)\n    },\n    [theme.palette.primary.dark, theme.palette.secondary.dark]\n  );\n\n  useEffect(\n    () => {\n      if (props.autoplay) {\n        waveSurferRef.current?.on('ready', play);\n      }\n      else {\n        waveSurferRef.current?.un('ready');\n      }\n    },\n    [props.autoplay],\n  )\n\n  useEffect(\n    () => {\n      if (props.audioPath) {\n        waveSurferRef.current?.load(props.audioPath);\n      } else {\n        waveSurferRef.current?.empty()\n      }\n    },\n    [props.audioPath],\n  );\n\n  useEffect(\n    () => {\n      if (props.loop) {\n        waveSurferRef.current?.on('finish', play);\n      }\n      else {\n        waveSurferRef.current?.un('finish');\n      }\n    },\n    [props.loop]\n  );\n\n  function play() {\n    waveSurferRef.current?.play();\n  }\n\n  function pause() {\n    waveSurferRef.current?.pause();\n  }\n\n  return (\n    <Box>\n      <h2>AudioDisplay WIP: {props.name || \"No Name\"}</h2>\n      <p>Audio Path: {props.audioPath}</p>\n      <p>Audio Duration: {waveSurferRef.current?.getDuration() * 1000}ms</p>{/* FIXME: duration not available until later; use state */}\n      <div ref={waveSurferDomRef}></div>\n      <Button onClick={play}>Play Audio</Button>\n      <Button onClick={pause}>Pause Audio</Button>\n    </Box>\n  );\n}\n\nexport default AudioDisplay;\n","import randomWords from 'random-words';\nimport { MuesliAudioClip } from './Types';\n\nfunction detectSilence(\n  audioCtx: AudioContext,\n  sourceAudioNode: AudioNode,\n  silence_delay_ms: number,\n  min_decibels: number,\n  onSoundStart = () => {},\n  onSoundEnd = () => {},\n  ): () => void {\n  const analyserNode = new AnalyserNode(audioCtx, {\n    minDecibels: min_decibels,\n  });\n  sourceAudioNode.connect(analyserNode);\n\n  // FIXME: does this leak memory?\n  const data = new Uint8Array(analyserNode.frequencyBinCount); // will hold our data\n  let silence_start = performance.now();\n  let activelyRecording = false; // trigger only once per silence event\n\n  function loop() {\n    const now: DOMHighResTimeStamp = performance.now()\n    analyserNode.getByteFrequencyData(data); // get current data\n    if (data.some(v => v)) { // if there is data above the given db limit\n      if(!activelyRecording){\n        onSoundStart();\n        activelyRecording = true;\n        console.log(\"Detected Audio\")\n        }\n      silence_start = now; // set it to now\n    }\n    if (activelyRecording && now - silence_start > silence_delay_ms) {\n      onSoundEnd();\n      activelyRecording = false;\n      console.log(\"Detected Silence\")\n    }\n  }\n\n  const analysisInterval = setInterval(loop, 100);  // Arbitrary delay\n  // Cleanup Function\n  return () => {\n    clearInterval(analysisInterval)\n    console.log('Ran cleanup function for silence detection')\n  }\n}\n\nfunction recordAudioClips(\n  mediaStream: MediaStream,\n  onNewClip: (clip: MuesliAudioClip) => void,\n  silenceDetectionPeriodMs: number,\n  insignificantClipDurationMs: number,  // Clips shorter than this won't be saved\n  // FIXME: move magic numbers into UI controls\n  silenceThresholdDbfs = -60,\n  recordingPeriodExtensionMs = 500,  // How much audio is retained in each clip before and after silence\n  ): () => void {\n  // Compute remaining time periods\n  // NOTE: there appears to be an undocumented minimum chunk size value o ~60ms (on Firefox at least).\n  // Below 60ms, this implementation breaks since it relies on the chunk size being valid to trim the audio correctly.\n  // FIXME: split audio based on samples/timestamps rather than relying on the recorder to work properly\n  const chunkSizeMs = 100;  // pretty arbitrary; tradeoff between precision and performance\n  const numChunksToTrimFromRecordingEnd = (silenceDetectionPeriodMs - 2 * recordingPeriodExtensionMs) / chunkSizeMs;\n  const numChunksForInsignificantClip = insignificantClipDurationMs / chunkSizeMs;\n\n  // Set up AudioContext\n  const audioCtx = new AudioContext();\n  const sourceNode = audioCtx.createMediaStreamSource(mediaStream);\n\n  // Record from stream on a delay to allow capturing audio\n  // from before recording is triggered\n  const delayNode = new DelayNode(audioCtx, {\n    delayTime: recordingPeriodExtensionMs / 1000,\n    maxDelayTime: recordingPeriodExtensionMs / 1000,\n  });\n  const destinationNode = audioCtx.createMediaStreamDestination();\n  sourceNode.connect(delayNode).connect(destinationNode);\n  const recorder = new MediaRecorder(destinationNode.stream);\n\n  let chunks: Blob[] = []\n  recorder.ondataavailable =\n    function(e) {\n        chunks.push(e.data);\n    }\n\n  recorder.onstop =\n    function(e) {\n      if (chunks.length <= numChunksForInsignificantClip) {\n        // Drop this clip as it's too short to be an actual recording\n        console.log(\"Skipping Audio conversion as number of chunks\", chunks.length, \"<=\", numChunksForInsignificantClip)\n      } else {\n        // Convert recorded audio, trimming off the final silence\n        console.log(\"Converting Audio as number of chunks\", chunks.length, \">\", numChunksForInsignificantClip, \"- trimming\", numChunksToTrimFromRecordingEnd)\n        const blob = new Blob(chunks.slice(0, chunks.length - numChunksToTrimFromRecordingEnd), { 'type' : 'audio/ogg; codecs=opus' });\n        const newClip = {\n          name: randomWords({exactly: 1, wordsPerString: 2, separator: '-'})[0],  // Returns array for some reason\n          url: window.URL.createObjectURL(blob)\n        }\n        console.log(\"Generated clip\", newClip);\n        onNewClip(newClip)\n      }\n\n      // Reset for next recording\n      chunks = [];\n    }\n\n  // Detect silence on the live audio\n  const stopSilenceDetection = detectSilence(\n    audioCtx,\n    sourceNode,\n    silenceDetectionPeriodMs,\n    silenceThresholdDbfs,\n    () => recorder.start(chunkSizeMs),\n    () => recorder.stop(),\n  );\n\n  // Cleanup Function\n  return () => {\n    stopSilenceDetection()\n    if (recorder.state === 'recording')\n    {\n      // If a recording was in progress, get that recording\n      // FIXME: prevent trimming end of audio in this case\n      recorder.stop()\n    }\n    audioCtx.close()\n    mediaStream.getTracks().forEach(track => track.stop());\n    console.log('Ran cleanup function for recording routine')\n    //FIXME: this leaks the 'recorder'.  No clue how to resolve this\n  }\n}\n\nexport default recordAudioClips;","import { TextField } from '@mui/material';\nimport { ChangeEvent, useState } from \"react\";\n\ntype NumberComponentProps = {\n  minValue?: number,\n  maxValue?: number,\n  onChange?: (validatedInput: number) => void;  // FIXME: is this idiomatic or should it fire an event?\n}\n\nfunction NumberTextField(props: NumberComponentProps) {\n  const [inputHasError, setInputHasError] = useState(false);\n\n  function ingestInput(e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) {\n    const inputValue = Number(e.target.value)\n    if (\n      !e.target.value.trim()  // Input string is whitespace\n      || isNaN(inputValue)\n      || (props.minValue && inputValue < props.minValue)\n      || (props.maxValue && inputValue > props.maxValue)\n    ) {\n      setInputHasError(true)\n    } else {\n      setInputHasError(false)\n      if (props.onChange) {\n        // Pass event through\n        props.onChange(inputValue)\n      }\n    }\n  }\n\n  function prepareHelperText(): string | undefined {\n    if (inputHasError) {\n      if (props.minValue && props.maxValue) {\n        return `Value must be a number between ${props.minValue} and ${props.maxValue}`\n      } else if (props.minValue) {\n        return `Value must be a number at least ${props.minValue}`\n      } else if (props.maxValue) {\n        return `Value must be a number at most ${props.maxValue}`\n      } else {\n        return \"Value must be a number\"\n      }\n    } else {\n      return undefined\n    }\n  }\n\n  const { minValue, maxValue, onChange, ...passthroughProps } = props\n\n  return (\n    <TextField\n      error={inputHasError}\n      onChange={(text) => ingestInput(text)}\n      helperText={prepareHelperText()}\n      {...passthroughProps}\n    />\n  )\n}\n\nexport default NumberTextField;\n","import {\n  Box,\n  Checkbox,\n  Grid,\n  Tooltip,\n  FormGroup,\n  FormControlLabel,\n  TextField,\n  Stack,\n} from '@mui/material';\nimport React, {\n  useRef,\n  useState,\n} from \"react\";\nimport ToggleButton from './ToggleButton.tsx';\nimport AudioDisplay from './AudioDisplay.js';\nimport useKeypress from 'react-use-keypress';\n\nimport recordAudioClips from './Recorder'\nimport NumberTextField from './NumberTextField';\nimport './App.css'\n\n// Bug/Feature list:\n// TODO: Should NOT trim audio at all when the user invokes \"Stop Recording\"\n// TODO: Spacebar should pause/play the MOST RECENTLY CLICKED-ON AudioDisplay and do nothing else\n// TODO: Status icon when capturing clips\n// TODO: (s) adorment on recording timing controls\n// TODO: add silence calibration button\n\nfunction Dictaphone(props) {\n  // Set/cleared when the user toggles recording\n  const recordingCleanupFunction = useRef();\n  //TODO: disambiguate between mic open and actually recording\n  const [isRecording, setRecordingState] = useState()\n  const [insignificantClipDurationMs, setInsignificantClipDurationMs] = useState(1000)\n  const [silenceDetectionPeriodMs, setSilenceDetectionPeriodMs] = useState(2000)\n\n  useKeypress('r', (event) => {\n    if (event.altKey) {\n      toggleRecording()\n    }\n  });\n\n  const [audioClips, setAudioClips] = useState([])\n\n  function toggleRecording() {\n    if (isRecording) {\n      recordingCleanupFunction.current();\n      recordingCleanupFunction.current = null;\n      setRecordingState(false)\n    }\n    else {\n      navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: false\n      }).then(mediaStream => {\n        recordingCleanupFunction.current =\n          recordAudioClips(\n            mediaStream,\n            addAudioClip,\n            silenceDetectionPeriodMs,\n            insignificantClipDurationMs,\n          )\n      }\n      )\n      setRecordingState(true)\n    }\n  }\n\n  function addAudioClip(newClip) {\n    setAudioClips(clips => [newClip, ...clips])  // Most recent clip first\n  }\n\n  // For debugging state transitions on AudioDisplay\n  const [loop, setLoop] = useState(false)  // default to match checkbox\n  const [autoplay, setAutoplay] = useState(false)  // default to match checkbox\n\n  // FIXME: for some reason, wrapping the ToggleButton in Tooltip here\n  // only displays the Tooltip when after the first time the Button is clicked\n  // This is due to the ToggleButton not containing a Ref since it's a function object\n  // Need to either make it a class or find another way around\n  return (\n    <Box className=\"App\">\n      <h2>Dictaphone WIP \"Pumblechook\"</h2>\n      <Grid container spacing={2}>\n        <Grid item id=\"controls\" xs={5} sm={4} md={3} lg={2}>\n          <Stack spacing={2}>\n            <Tooltip title=\"Toggle with Alt-R\" arrow>\n              <ToggleButton\n                enabled={isRecording}\n                enableText=\"Start Recording\"\n                disableText=\"Stop Recording\"\n                onClick={toggleRecording}\n              />\n            </Tooltip>\n\n            <TextField\n              label=\"Custom Audio File Path\"\n              placeholder=\"(debug only)\"\n              onChange={(e) => setAudioClips([{ url: e.target.value }])}\n            />\n\n            <NumberTextField\n              disabled={isRecording}\n              label=\"Cut clip when silent for\"\n              placeholder=\"Time in seconds...\"\n              defaultValue={silenceDetectionPeriodMs / 1000}\n              minValue={1}\n              maxValue={15}\n              onChange={(value) => setSilenceDetectionPeriodMs(value * 1000)}\n            />\n\n            <NumberTextField\n              disabled={isRecording}\n              label=\"Discard clips shorter than\"\n              placeholder=\"Time in seconds...\"\n              defaultValue={insignificantClipDurationMs / 1000}\n              minValue={0}\n              maxValue={5}\n              onChange={(value) => setInsignificantClipDurationMs(value * 1000)}\n            />\n\n            <FormGroup>\n              <FormControlLabel control={<Checkbox onChange={(e) => setLoop(e.target.checked)} />} label=\"Loop\" />\n              <FormControlLabel control={<Checkbox onChange={(e) => setAutoplay(e.target.checked)} />} label=\"Autoplay\" />\n            </FormGroup>\n          </Stack>\n        </Grid>\n        <Grid item id=\"clips\" xs={7} sm={8} md={9} lg={10}>\n          <Stack spacing={2}>\n            {/* FIXME: Update key with some server-sidable ID instead of the URL?*/}\n            {audioClips.map(clip => <AudioDisplay key={clip.url} name={clip.name} audioPath={clip.url} autoplay={autoplay} loop={loop} />)}\n          </Stack>\n        </Grid>\n      </Grid>\n    </Box>\n  );\n}\n\nexport default Dictaphone;\n","import { ThemeProvider, createTheme } from '@mui/material/styles';\nimport { CssBaseline } from '@mui/material';\nimport './App.css';\n\n// import LandingPage from './LandingPage.js';\nimport Dictaphone from './Dictaphone.js';\n\nfunction App() {\n  const darkTheme = createTheme({\n    palette: {\n      mode: 'dark',\n      background: {\n        default: \"#10051a\"\n      },\n    },\n    components: {\n      MuiButton: {\n        defaultProps: {\n          variant: 'outlined',\n        },\n      },\n    },\n  });\n\n  return (\n    <ThemeProvider theme={darkTheme}>\n      <CssBaseline />\n      {/* <LandingPage /> */}\n      <Dictaphone />\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}